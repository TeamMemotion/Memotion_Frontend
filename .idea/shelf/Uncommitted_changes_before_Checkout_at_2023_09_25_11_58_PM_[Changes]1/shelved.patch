Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/InstantPlacementSettings.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/InstantPlacementSettings.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/InstantPlacementSettings.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/InstantPlacementSettings.java	
+++ /dev/null	
@@ -1,52 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-
-/** Manages the Instant Placement option setting and shared preferences. */
-public class InstantPlacementSettings {
-  public static final String SHARED_PREFERENCES_ID = "SHARED_PREFERENCES_INSTANT_PLACEMENT_OPTIONS";
-  public static final String SHARED_PREFERENCES_INSTANT_PLACEMENT_ENABLED =
-      "instant_placement_enabled";
-  private boolean instantPlacementEnabled = true;
-  private SharedPreferences sharedPreferences;
-
-  /** Initializes the current settings based on the saved value. */
-  public void onCreate(Context context) {
-    sharedPreferences = context.getSharedPreferences(SHARED_PREFERENCES_ID, Context.MODE_PRIVATE);
-    instantPlacementEnabled =
-        sharedPreferences.getBoolean(SHARED_PREFERENCES_INSTANT_PLACEMENT_ENABLED, false);
-  }
-
-  /** Retrieves whether Instant Placement is enabled, */
-  public boolean isInstantPlacementEnabled() {
-    return instantPlacementEnabled;
-  }
-
-  public void setInstantPlacementEnabled(boolean enable) {
-    if (enable == instantPlacementEnabled) {
-      return; // No change.
-    }
-
-    // Updates the stored default settings.
-    instantPlacementEnabled = enable;
-    SharedPreferences.Editor editor = sharedPreferences.edit();
-    editor.putBoolean(SHARED_PREFERENCES_INSTANT_PLACEMENT_ENABLED, instantPlacementEnabled);
-    editor.apply();
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/CameraPermissionHelper.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/CameraPermissionHelper.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/CameraPermissionHelper.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/CameraPermissionHelper.java	
+++ /dev/null	
@@ -1,57 +0,0 @@
-/*
- * Copyright 2017 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.net.Uri;
-import android.provider.Settings;
-
-import androidx.core.app.ActivityCompat;
-import androidx.core.content.ContextCompat;
-
-/** Helper to ask camera permission. */
-public final class CameraPermissionHelper {
-  private static final int CAMERA_PERMISSION_CODE = 0;
-  private static final String CAMERA_PERMISSION = Manifest.permission.CAMERA;
-
-  /** Check to see we have the necessary permissions for this app. */
-  public static boolean hasCameraPermission(Activity activity) {
-    return ContextCompat.checkSelfPermission(activity, CAMERA_PERMISSION)
-        == PackageManager.PERMISSION_GRANTED;
-  }
-
-  /** Check to see we have the necessary permissions for this app, and ask for them if we don't. */
-  public static void requestCameraPermission(Activity activity) {
-    ActivityCompat.requestPermissions(
-        activity, new String[] {CAMERA_PERMISSION}, CAMERA_PERMISSION_CODE);
-  }
-
-  /** Check to see if we need to show the rationale for this permission. */
-  public static boolean shouldShowRequestPermissionRationale(Activity activity) {
-    return ActivityCompat.shouldShowRequestPermissionRationale(activity, CAMERA_PERMISSION);
-  }
-
-  /** Launch Application Setting to grant permission. */
-  public static void launchPermissionSettings(Activity activity) {
-    Intent intent = new Intent();
-    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
-    intent.setData(Uri.fromParts("package", activity.getPackageName(), null));
-    activity.startActivity(intent);
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/Mesh.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Mesh.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Mesh.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Mesh.java	
+++ /dev/null	
@@ -1,196 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.opengl.GLES30;
-import android.util.Log;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import de.javagl.obj.Obj;
-import de.javagl.obj.ObjData;
-import de.javagl.obj.ObjReader;
-import de.javagl.obj.ObjUtils;
-
-/**
- * A collection of vertices, faces, and other attributes that define how to render a 3D object.
- *
- * <p>To render the mesh, use {@link SampleRender#draw()}.
- */
-public class Mesh implements Closeable {
-  private static final String TAG = Mesh.class.getSimpleName();
-
-  /**
-   * The kind of primitive to render.
-   *
-   * <p>This determines how the data in {@link VertexBuffer}s are interpreted. See <a
-   * href="https://www.khronos.org/opengl/wiki/Primitive">here</a> for more on how primitives
-   * behave.
-   */
-  public enum PrimitiveMode {
-    POINTS(GLES30.GL_POINTS),
-    LINE_STRIP(GLES30.GL_LINE_STRIP),
-    LINE_LOOP(GLES30.GL_LINE_LOOP),
-    LINES(GLES30.GL_LINES),
-    TRIANGLE_STRIP(GLES30.GL_TRIANGLE_STRIP),
-    TRIANGLE_FAN(GLES30.GL_TRIANGLE_FAN),
-    TRIANGLES(GLES30.GL_TRIANGLES);
-
-    /* package-private */
-    final int glesEnum;
-
-    private PrimitiveMode(int glesEnum) {
-      this.glesEnum = glesEnum;
-    }
-  }
-
-  private final int[] vertexArrayId = {0};
-  private final PrimitiveMode primitiveMode;
-  private final IndexBuffer indexBuffer;
-  private final VertexBuffer[] vertexBuffers;
-
-  /**
-   * Construct a {@link Mesh}.
-   *
-   * <p>The data in the given {@link IndexBuffer} and {@link VertexBuffer}s does not need to be
-   * finalized; they may be freely changed throughout the lifetime of a {@link Mesh} using their
-   * respective {@code set()} methods.
-   *
-   * <p>The ordering of the {@code vertexBuffers} is significant. Their array indices will
-   * correspond to their attribute locations, which must be taken into account in shader code. The
-   * <a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)">layout qualifier</a> must
-   * be used in the vertex shader code to explicitly associate attributes with these indices.
-   */
-  public Mesh(
-      SampleRender render,
-      PrimitiveMode primitiveMode,
-      IndexBuffer indexBuffer,
-      VertexBuffer[] vertexBuffers) {
-    if (vertexBuffers == null || vertexBuffers.length == 0) {
-      throw new IllegalArgumentException("Must pass at least one vertex buffer");
-    }
-
-    this.primitiveMode = primitiveMode;
-    this.indexBuffer = indexBuffer;
-    this.vertexBuffers = vertexBuffers;
-
-    try {
-      // Create vertex array
-      GLES30.glGenVertexArrays(1, vertexArrayId, 0);
-      GLError.maybeThrowGLException("Failed to generate a vertex array", "glGenVertexArrays");
-
-      // Bind vertex array
-      GLES30.glBindVertexArray(vertexArrayId[0]);
-      GLError.maybeThrowGLException("Failed to bind vertex array object", "glBindVertexArray");
-
-      if (indexBuffer != null) {
-        GLES30.glBindBuffer(GLES30.GL_ELEMENT_ARRAY_BUFFER, indexBuffer.getBufferId());
-      }
-
-      for (int i = 0; i < vertexBuffers.length; ++i) {
-        // Bind each vertex buffer to vertex array
-        GLES30.glBindBuffer(GLES30.GL_ARRAY_BUFFER, vertexBuffers[i].getBufferId());
-        GLError.maybeThrowGLException("Failed to bind vertex buffer", "glBindBuffer");
-        GLES30.glVertexAttribPointer(
-            i, vertexBuffers[i].getNumberOfEntriesPerVertex(), GLES30.GL_FLOAT, false, 0, 0);
-        GLError.maybeThrowGLException(
-            "Failed to associate vertex buffer with vertex array", "glVertexAttribPointer");
-        GLES30.glEnableVertexAttribArray(i);
-        GLError.maybeThrowGLException(
-            "Failed to enable vertex buffer", "glEnableVertexAttribArray");
-      }
-    } catch (Throwable t) {
-      close();
-      throw t;
-    }
-  }
-
-  /**
-   * Constructs a {@link Mesh} from the given Wavefront OBJ file.
-   *
-   * <p>The {@link Mesh} will be constructed with three attributes, indexed in the order of local
-   * coordinates (location 0, vec3), texture coordinates (location 1, vec2), and vertex normals
-   * (location 2, vec3).
-   */
-  public static Mesh createFromAsset(SampleRender render, String assetFileName) throws IOException {
-    try (InputStream inputStream = render.getAssets().open(assetFileName)) {
-      Obj obj = ObjUtils.convertToRenderable(ObjReader.read(inputStream));
-
-      // Obtain the data from the OBJ, as direct buffers:
-      IntBuffer vertexIndices = ObjData.getFaceVertexIndices(obj, /*numVerticesPerFace=*/ 3);
-      FloatBuffer localCoordinates = ObjData.getVertices(obj);
-      FloatBuffer textureCoordinates = ObjData.getTexCoords(obj, /*dimensions=*/ 2);
-      FloatBuffer normals = ObjData.getNormals(obj);
-
-      VertexBuffer[] vertexBuffers = {
-        new VertexBuffer(render, 3, localCoordinates),
-        new VertexBuffer(render, 2, textureCoordinates),
-        new VertexBuffer(render, 3, normals),
-      };
-
-      IndexBuffer indexBuffer = new IndexBuffer(render, vertexIndices);
-
-      return new Mesh(render, PrimitiveMode.TRIANGLES, indexBuffer, vertexBuffers);
-    }
-  }
-
-  @Override
-  public void close() {
-    if (vertexArrayId[0] != 0) {
-      GLES30.glDeleteVertexArrays(1, vertexArrayId, 0);
-      GLError.maybeLogGLError(
-          Log.WARN, TAG, "Failed to free vertex array object", "glDeleteVertexArrays");
-    }
-  }
-
-  /**
-   * Draws the mesh. Don't call this directly unless you are doing low level OpenGL code; instead,
-   * prefer {@link SampleRender#draw}.
-   */
-  public void lowLevelDraw() {
-    if (vertexArrayId[0] == 0) {
-      throw new IllegalStateException("Tried to draw a freed Mesh");
-    }
-
-    GLES30.glBindVertexArray(vertexArrayId[0]);
-    GLError.maybeThrowGLException("Failed to bind vertex array object", "glBindVertexArray");
-    if (indexBuffer == null) {
-      // Sanity check for debugging
-      int vertexCount = vertexBuffers[0].getNumberOfVertices();
-      for (int i = 1; i < vertexBuffers.length; ++i) {
-        int iterCount = vertexBuffers[i].getNumberOfVertices();
-        if (iterCount != vertexCount) {
-          throw new IllegalStateException(
-              String.format(
-                  "Vertex buffers have mismatching numbers of vertices ([0] has %d but [%d] has"
-                      + " %d)",
-                  vertexCount, i, iterCount));
-        }
-      }
-      GLES30.glDrawArrays(primitiveMode.glesEnum, 0, vertexCount);
-      GLError.maybeThrowGLException("Failed to draw vertex array object", "glDrawArrays");
-    } else {
-      GLES30.glDrawElements(
-          primitiveMode.glesEnum, indexBuffer.getSize(), GLES30.GL_UNSIGNED_INT, 0);
-      GLError.maybeThrowGLException(
-          "Failed to draw vertex array object with indices", "glDrawElements");
-    }
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/SnackbarHelper.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/SnackbarHelper.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/SnackbarHelper.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/SnackbarHelper.java	
+++ /dev/null	
@@ -1,160 +0,0 @@
-/*
- * Copyright 2017 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.app.Activity;
-import android.view.View;
-import android.widget.TextView;
-
-import com.google.android.material.snackbar.BaseTransientBottomBar;
-import com.google.android.material.snackbar.Snackbar;
-
-/**
- * Helper to manage the sample snackbar. Hides the Android boilerplate code, and exposes simpler
- * methods.
- */
-public final class SnackbarHelper {
-  private static final int BACKGROUND_COLOR = 0xbf323232;
-  private Snackbar messageSnackbar;
-  private enum DismissBehavior { HIDE, SHOW, FINISH };
-  private int maxLines = 2;
-  private String lastMessage = "";
-  private View snackbarView;
-
-  public boolean isShowing() {
-    return messageSnackbar != null;
-  }
-
-  /** Shows a snackbar with a given message. */
-  public void showMessage(Activity activity, String message) {
-    if (!message.isEmpty() && (!isShowing() || !lastMessage.equals(message))) {
-      lastMessage = message;
-      show(activity, message, DismissBehavior.HIDE);
-    }
-  }
-
-  /** Shows a snackbar with a given message, and a dismiss button. */
-  public void showMessageWithDismiss(Activity activity, String message) {
-    show(activity, message, DismissBehavior.SHOW);
-  }
-
-  /** Shows a snackbar with a given message for Snackbar.LENGTH_SHORT milliseconds */
-  public void showMessageForShortDuration(Activity activity, String message) {
-    show(activity, message, DismissBehavior.SHOW, Snackbar.LENGTH_SHORT);
-  }
-
-  /** Shows a snackbar with a given message for Snackbar.LENGTH_LONG milliseconds */
-  public void showMessageForLongDuration(Activity activity, String message) {
-    show(activity, message, DismissBehavior.SHOW, Snackbar.LENGTH_LONG);
-  }
-
-  /**
-   * Shows a snackbar with a given error message. When dismissed, will finish the activity. Useful
-   * for notifying errors, where no further interaction with the activity is possible.
-   */
-  public void showError(Activity activity, String errorMessage) {
-    show(activity, errorMessage, DismissBehavior.FINISH);
-  }
-
-  /**
-   * Hides the currently showing snackbar, if there is one. Safe to call from any thread. Safe to
-   * call even if snackbar is not shown.
-   */
-  public void hide(Activity activity) {
-    if (!isShowing()) {
-      return;
-    }
-    lastMessage = "";
-    Snackbar messageSnackbarToHide = messageSnackbar;
-    messageSnackbar = null;
-    activity.runOnUiThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            messageSnackbarToHide.dismiss();
-          }
-        });
-  }
-
-  public void setMaxLines(int lines) {
-    maxLines = lines;
-  }
-
-  /**
-   * Sets the view that will be used to find a suitable parent view to hold the Snackbar view.
-   *
-   * <p>To use the root layout ({@link android.R.id.content}), pass in {@code null}.
-   *
-   * @param snackbarView the view to pass to {@link
-   *     Snackbar#make(…)} which will be used to find a
-   *     suitable parent, which is a {@link androidx.coordinatorlayout.widget.CoordinatorLayout}, or
-   *     the window decor's content view, whichever comes first.
-   */
-  public void setParentView(View snackbarView) {
-    this.snackbarView = snackbarView;
-  }
-
-  private void show(Activity activity, String message, DismissBehavior dismissBehavior) {
-    show(activity, message, dismissBehavior, Snackbar.LENGTH_INDEFINITE);
-  }
-
-  private void show(
-      final Activity activity,
-      final String message,
-      final DismissBehavior dismissBehavior,
-      int duration) {
-    activity.runOnUiThread(
-        new Runnable() {
-          @Override
-          public void run() {
-            messageSnackbar =
-                Snackbar.make(
-                    snackbarView == null
-                        ? activity.findViewById(android.R.id.content)
-                        : snackbarView,
-                    message,
-                    duration);
-            messageSnackbar.getView().setBackgroundColor(BACKGROUND_COLOR);
-            if (dismissBehavior != DismissBehavior.HIDE && duration == Snackbar.LENGTH_INDEFINITE) {
-              messageSnackbar.setAction(
-                  "Dismiss",
-                  new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                      messageSnackbar.dismiss();
-                    }
-                  });
-              if (dismissBehavior == DismissBehavior.FINISH) {
-                messageSnackbar.addCallback(
-                    new BaseTransientBottomBar.BaseCallback<Snackbar>() {
-                      @Override
-                      public void onDismissed(Snackbar transientBottomBar, int event) {
-                        super.onDismissed(transientBottomBar, event);
-                        activity.finish();
-                      }
-                    });
-              }
-            }
-            ((TextView)
-                    messageSnackbar
-                        .getView()
-                        .findViewById(com.google.android.material.R.id.snackbar_text))
-                .setMaxLines(maxLines);
-            messageSnackbar.show();
-          }
-        });
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/VertexBuffer.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/VertexBuffer.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/VertexBuffer.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/VertexBuffer.java	
+++ /dev/null	
@@ -1,102 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.opengl.GLES30;
-
-import java.io.Closeable;
-import java.nio.FloatBuffer;
-
-/**
- * A list of vertex attribute data stored GPU-side.
- *
- * <p>One or more {@link VertexBuffer}s are used when constructing a {@link Mesh} to describe vertex
- * attribute data; for example, local coordinates, texture coordinates, vertex normals, etc.
- *
- * @see <a
- *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glVertexAttribPointer.xhtml">glVertexAttribPointer</a>
- */
-public class VertexBuffer implements Closeable {
-  private final GpuBuffer buffer;
-  private final int numberOfEntriesPerVertex;
-
-  /**
-   * Construct a {@link VertexBuffer} populated with initial data.
-   *
-   * <p>The GPU buffer will be filled with the data in the <i>direct</i> buffer {@code entries},
-   * starting from the beginning of the buffer (not the current cursor position). The cursor will be
-   * left in an undefined position after this function returns.
-   *
-   * <p>The number of vertices in the buffer can be expressed as {@code entries.limit() /
-   * numberOfEntriesPerVertex}. Thus, The size of the buffer must be divisible by {@code
-   * numberOfEntriesPerVertex}.
-   *
-   * <p>The {@code entries} buffer may be null, in which case an empty buffer is constructed
-   * instead.
-   */
-  public VertexBuffer(SampleRender render, int numberOfEntriesPerVertex, FloatBuffer entries) {
-    if (entries != null && entries.limit() % numberOfEntriesPerVertex != 0) {
-      throw new IllegalArgumentException(
-          "If non-null, vertex buffer data must be divisible by the number of data points per"
-              + " vertex");
-    }
-
-    this.numberOfEntriesPerVertex = numberOfEntriesPerVertex;
-    buffer = new GpuBuffer(GLES30.GL_ARRAY_BUFFER, GpuBuffer.FLOAT_SIZE, entries);
-  }
-
-  /**
-   * Populate with new data.
-   *
-   * <p>The entire buffer is replaced by the contents of the <i>direct</i> buffer {@code entries}
-   * starting from the beginning of the buffer, not the current cursor position. The cursor will be
-   * left in an undefined position after this function returns.
-   *
-   * <p>The GPU buffer is reallocated automatically if necessary.
-   *
-   * <p>The {@code entries} buffer may be null, in which case the buffer will become empty.
-   * Otherwise, the size of {@code entries} must be divisible by the number of entries per vertex
-   * specified during construction.
-   */
-  public void set(FloatBuffer entries) {
-    if (entries != null && entries.limit() % numberOfEntriesPerVertex != 0) {
-      throw new IllegalArgumentException(
-          "If non-null, vertex buffer data must be divisible by the number of data points per"
-              + " vertex");
-    }
-    buffer.set(entries);
-  }
-
-  @Override
-  public void close() {
-    buffer.free();
-  }
-
-  /* package-private */
-  int getBufferId() {
-    return buffer.getBufferId();
-  }
-
-  /* package-private */
-  int getNumberOfEntriesPerVertex() {
-    return numberOfEntriesPerVertex;
-  }
-
-  /* package-private */
-  int getNumberOfVertices() {
-    return buffer.getSize() / numberOfEntriesPerVertex;
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/LocationPermissionHelper.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/LocationPermissionHelper.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/LocationPermissionHelper.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/LocationPermissionHelper.java	
+++ /dev/null	
@@ -1,68 +0,0 @@
-/*
- * Copyright 2022 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.net.Uri;
-import android.provider.Settings;
-
-import androidx.core.app.ActivityCompat;
-import androidx.core.content.ContextCompat;
-
-/** Helper to ask location permission. */
-public final class LocationPermissionHelper {
-  private static final int LOCATION_PERMISSION_CODE = 1;
-  private static final String LOCATION_PERMISSION = Manifest.permission.ACCESS_FINE_LOCATION;
-
-  /** Check to see we have the necessary permissions for this app. */
-  public static boolean hasFineLocationPermission(Activity activity) {
-    return ContextCompat.checkSelfPermission(activity, LOCATION_PERMISSION)
-        == PackageManager.PERMISSION_GRANTED;
-  }
-
-  /** Check to see we have the necessary permissions for this app, and ask for them if we don't. */
-  public static void requestFineLocationPermission(Activity activity) {
-    ActivityCompat.requestPermissions(
-        activity, new String[] {LOCATION_PERMISSION}, LOCATION_PERMISSION_CODE);
-  }
-
-  /** Check to see if the array of given permissions contain the location permission. */
-  public static boolean hasFineLocationPermissionsResponseInResult(String[] permissions) {
-    for (String permission : permissions) {
-      if (LOCATION_PERMISSION.equals(permission)) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  /** Check to see if we need to show the rationale for this permission. */
-  public static boolean shouldShowRequestPermissionRationale(Activity activity) {
-    return ActivityCompat.shouldShowRequestPermissionRationale(activity, LOCATION_PERMISSION);
-  }
-
-  /** Launch Application Setting to grant permission. */
-  public static void launchPermissionSettings(Activity activity) {
-    Intent intent = new Intent();
-    intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
-    intent.setData(Uri.fromParts("package", activity.getPackageName(), null));
-    activity.startActivity(intent);
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/SpecularCubemapFilter.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/SpecularCubemapFilter.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/SpecularCubemapFilter.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/SpecularCubemapFilter.java	
+++ /dev/null	
@@ -1,527 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender.arcore;
-
-import static java.lang.Math.max;
-import static java.lang.Math.min;
-
-import android.media.Image;
-import android.opengl.GLES30;
-import android.util.Log;
-
-import com.example.memotion.arcamera.common.samplerender.GLError;
-import com.example.memotion.arcamera.common.samplerender.Mesh;
-import com.example.memotion.arcamera.common.samplerender.SampleRender;
-import com.example.memotion.arcamera.common.samplerender.Shader;
-import com.example.memotion.arcamera.common.samplerender.Texture;
-import com.example.memotion.arcamera.common.samplerender.VertexBuffer;
-import com.google.ar.core.ImageFormat;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-
-/**
- * Filters a provided cubemap into a cubemap lookup texture which is a function of the direction of
- * a reflected ray of light and material roughness, i.e. the LD term of the specular IBL
- * calculation.
- *
- * <p>See https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights for a more
- * detailed explanation.
- */
-public class SpecularCubemapFilter implements Closeable {
-  private static final String TAG = SpecularCubemapFilter.class.getSimpleName();
-
-  private static final int COMPONENTS_PER_VERTEX = 2;
-  private static final int NUMBER_OF_VERTICES = 4;
-  private static final int FLOAT_SIZE = 4;
-  private static final int COORDS_BUFFER_SIZE =
-      COMPONENTS_PER_VERTEX * NUMBER_OF_VERTICES * FLOAT_SIZE;
-
-  private static final int NUMBER_OF_CUBE_FACES = 6;
-
-  private static final FloatBuffer COORDS_BUFFER =
-      ByteBuffer.allocateDirect(COORDS_BUFFER_SIZE).order(ByteOrder.nativeOrder()).asFloatBuffer();
-
-  static {
-    COORDS_BUFFER.put(
-        new float[] {
-          /*0:*/ -1f, -1f, /*1:*/ +1f, -1f, /*2:*/ -1f, +1f, /*3:*/ +1f, +1f,
-        });
-  }
-
-  private static final String[] ATTACHMENT_LOCATION_DEFINES = {
-    "PX_LOCATION", "NX_LOCATION", "PY_LOCATION", "NY_LOCATION", "PZ_LOCATION", "NZ_LOCATION",
-  };
-
-  private static final int[] ATTACHMENT_ENUMS = {
-    GLES30.GL_COLOR_ATTACHMENT0,
-    GLES30.GL_COLOR_ATTACHMENT1,
-    GLES30.GL_COLOR_ATTACHMENT2,
-    GLES30.GL_COLOR_ATTACHMENT3,
-    GLES30.GL_COLOR_ATTACHMENT4,
-    GLES30.GL_COLOR_ATTACHMENT5,
-  };
-
-  // We need to create enough shaders and framebuffers to encompass every face of the cubemap. Each
-  // color attachment is used by the framebuffer to render to a different face of the cubemap, so we
-  // use "chunks" which define as many color attachments as possible for each face. For example, if
-  // we have a maximum of 3 color attachments, we must create two shaders with the following color
-  // attachments:
-  //
-  // layout(location = 0) out vec4 o_FragColorPX;
-  // layout(location = 1) out vec4 o_FragColorNX;
-  // layout(location = 2) out vec4 o_FragColorPY;
-  //
-  // and
-  //
-  // layout(location = 0) out vec4 o_FragColorNY;
-  // layout(location = 1) out vec4 o_FragColorPZ;
-  // layout(location = 2) out vec4 o_FragColorNZ;
-  private static class Chunk {
-    public final int chunkIndex;
-    public final int chunkSize;
-    public final int firstFaceIndex;
-
-    public Chunk(int chunkIndex, int maxChunkSize) {
-      this.chunkIndex = chunkIndex;
-      this.firstFaceIndex = chunkIndex * maxChunkSize;
-      this.chunkSize = min(maxChunkSize, NUMBER_OF_CUBE_FACES - this.firstFaceIndex);
-    }
-  }
-
-  private static class ChunkIterable implements Iterable<Chunk> {
-    public final int maxChunkSize;
-    public final int numberOfChunks;
-
-    public ChunkIterable(int maxNumberOfColorAttachments) {
-      this.maxChunkSize = min(maxNumberOfColorAttachments, NUMBER_OF_CUBE_FACES);
-      int numberOfChunks = NUMBER_OF_CUBE_FACES / this.maxChunkSize;
-      if (NUMBER_OF_CUBE_FACES % this.maxChunkSize != 0) {
-        numberOfChunks++;
-      }
-      this.numberOfChunks = numberOfChunks;
-    }
-
-    @Override
-    public Iterator<Chunk> iterator() {
-      return new Iterator<Chunk>() {
-        private Chunk chunk = new Chunk(/*chunkIndex=*/ 0, maxChunkSize);
-
-        @Override
-        public boolean hasNext() {
-          return chunk.chunkIndex < numberOfChunks;
-        }
-
-        @Override
-        public Chunk next() {
-          Chunk result = this.chunk;
-          this.chunk = new Chunk(result.chunkIndex + 1, maxChunkSize);
-          return result;
-        }
-      };
-    }
-  }
-
-  private static class ImportanceSampleCacheEntry {
-    public float[] direction;
-    public float contribution;
-    public float level;
-  }
-
-  private final int resolution;
-  private final int numberOfImportanceSamples;
-  private final int numberOfMipmapLevels;
-
-  private final Texture radianceCubemap;
-  private final Texture ldCubemap;
-  // Indexed by attachment chunk.
-  private final Shader[] shaders;
-  private final Mesh mesh;
-
-  // Using OpenGL directly here since cubemap framebuffers are very involved. Indexed by
-  // [mipmapLevel][attachmentChunk].
-  private final int[][] framebuffers;
-
-  /**
-   * Constructs a {@link SpecularCubemapFilter}.
-   *
-   * <p>The provided resolution refers to both the width and height of the input resolution and the
-   * resolution of the highest mipmap level of the filtered cubemap texture.
-   *
-   * <p>Ideally, the cubemap would need to be filtered by computing a function of every sample over
-   * the hemisphere for every texel. Since this is not practical to compute, a limited, discrete
-   * number of importance samples are selected instead. A larger number of importance samples will
-   * generally provide more accurate results, but in the case of ARCore, the cubemap estimations are
-   * already very low resolution, and higher values provide rapidly diminishing returns.
-   */
-  public SpecularCubemapFilter(SampleRender render, int resolution, int numberOfImportanceSamples)
-      throws IOException {
-    this.resolution = resolution;
-    this.numberOfImportanceSamples = numberOfImportanceSamples;
-    this.numberOfMipmapLevels = log2(resolution) + 1;
-
-    try {
-      radianceCubemap =
-          new Texture(render, Texture.Target.TEXTURE_CUBE_MAP, Texture.WrapMode.CLAMP_TO_EDGE);
-      ldCubemap =
-          new Texture(render, Texture.Target.TEXTURE_CUBE_MAP, Texture.WrapMode.CLAMP_TO_EDGE);
-
-      ChunkIterable chunks = new ChunkIterable(getMaxColorAttachments());
-      initializeLdCubemap();
-      shaders = createShaders(render, chunks);
-      framebuffers = createFramebuffers(chunks);
-
-      // Create the quad mesh that encompasses the entire view.
-      VertexBuffer coordsBuffer = new VertexBuffer(render, COMPONENTS_PER_VERTEX, COORDS_BUFFER);
-      mesh =
-          new Mesh(
-              render,
-              Mesh.PrimitiveMode.TRIANGLE_STRIP,
-              /*indexBuffer=*/ null,
-              new VertexBuffer[] {coordsBuffer});
-    } catch (Throwable t) {
-      close();
-      throw t;
-    }
-  }
-
-  @Override
-  public void close() {
-    if (framebuffers != null) {
-      for (int[] framebufferChunks : framebuffers) {
-        GLES30.glDeleteFramebuffers(framebufferChunks.length, framebufferChunks, 0);
-        GLError.maybeLogGLError(
-            Log.WARN, TAG, "Failed to free framebuffers", "glDeleteFramebuffers");
-      }
-    }
-    if (radianceCubemap != null) {
-      radianceCubemap.close();
-    }
-    if (ldCubemap != null) {
-      ldCubemap.close();
-    }
-    if (shaders != null) {
-      for (Shader shader : shaders) {
-        shader.close();
-      }
-    }
-  }
-
-//  /**
-//   * Updates and filters the provided cubemap textures from ARCore.
-//   *
-//   * <p>This method should be called every frame with the result of {@link
-//   * com.google.ar.core.LightEstimate.acquireEnvironmentalHdrCubeMap()} to update the filtered
-//   * cubemap texture, accessible via {@link getFilteredCubemapTexture()}.
-//   *
-//   * <p>The given {@link Image}s will be closed by this method, even if an exception occurs.
-//   */
-  public void update(Image[] images) {
-    try {
-      GLES30.glBindTexture(GLES30.GL_TEXTURE_CUBE_MAP, radianceCubemap.getTextureId());
-      GLError.maybeThrowGLException("Failed to bind radiance cubemap texture", "glBindTexture");
-
-      if (images.length != NUMBER_OF_CUBE_FACES) {
-        throw new IllegalArgumentException(
-            "Number of images differs from the number of sides of a cube.");
-      }
-
-      for (int i = 0; i < NUMBER_OF_CUBE_FACES; ++i) {
-        Image image = images[i];
-        // Sanity check for the format of the cubemap.
-        if (image.getFormat() != ImageFormat.RGBA_FP16) {
-          throw new IllegalArgumentException(
-              "Unexpected image format for cubemap: " + image.getFormat());
-        }
-        if (image.getHeight() != image.getWidth()) {
-          throw new IllegalArgumentException("Cubemap face is not square.");
-        }
-        if (image.getHeight() != resolution) {
-          throw new IllegalArgumentException(
-              "Cubemap face resolution ("
-                  + image.getHeight()
-                  + ") does not match expected value ("
-                  + resolution
-                  + ").");
-        }
-
-        GLES30.glTexImage2D(
-            GLES30.GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
-            /*level=*/ 0,
-            GLES30.GL_RGBA16F,
-            /*width=*/ resolution,
-            /*height=*/ resolution,
-            /*border=*/ 0,
-            GLES30.GL_RGBA,
-            GLES30.GL_HALF_FLOAT,
-            image.getPlanes()[0].getBuffer());
-        GLError.maybeThrowGLException("Failed to populate cubemap face", "glTexImage2D");
-      }
-
-      GLES30.glGenerateMipmap(GLES30.GL_TEXTURE_CUBE_MAP);
-      GLError.maybeThrowGLException("Failed to generate cubemap mipmaps", "glGenerateMipmap");
-
-      // Do the filtering operation, filling the mipmaps of ldTexture with the roughness filtered
-      // cubemap.
-      for (int level = 0; level < numberOfMipmapLevels; ++level) {
-        int mipmapResolution = resolution >> level;
-        GLES30.glViewport(0, 0, mipmapResolution, mipmapResolution);
-        GLError.maybeThrowGLException("Failed to set viewport dimensions", "glViewport");
-        for (int chunkIndex = 0; chunkIndex < shaders.length; ++chunkIndex) {
-          GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, framebuffers[level][chunkIndex]);
-          GLError.maybeThrowGLException("Failed to bind cubemap framebuffer", "glBindFramebuffer");
-          shaders[chunkIndex].setInt("u_RoughnessLevel", level);
-          shaders[chunkIndex].lowLevelUse();
-          mesh.lowLevelDraw();
-        }
-      }
-    } finally {
-      for (Image image : images) {
-        image.close();
-      }
-    }
-  }
-
-  /** Returns the number of mipmap levels in the filtered cubemap texture. */
-  public int getNumberOfMipmapLevels() {
-    return numberOfMipmapLevels;
-  }
-
-  /**
-   * Returns the filtered cubemap texture whose contents are updated with each call to {@link
-   * #update(Image[])}.
-   */
-  public Texture getFilteredCubemapTexture() {
-    return ldCubemap;
-  }
-
-  private void initializeLdCubemap() {
-    // Initialize mipmap levels of LD cubemap.
-    GLES30.glBindTexture(GLES30.GL_TEXTURE_CUBE_MAP, ldCubemap.getTextureId());
-    GLError.maybeThrowGLException("Could not bind LD cubemap texture", "glBindTexture");
-    for (int level = 0; level < numberOfMipmapLevels; ++level) {
-      int mipmapResolution = resolution >> level;
-      for (int face = 0; face < NUMBER_OF_CUBE_FACES; ++face) {
-        GLES30.glTexImage2D(
-            GLES30.GL_TEXTURE_CUBE_MAP_POSITIVE_X + face,
-            level,
-            GLES30.GL_RGB16F,
-            /*width=*/ mipmapResolution,
-            /*height=*/ mipmapResolution,
-            /*border=*/ 0,
-            GLES30.GL_RGB,
-            GLES30.GL_HALF_FLOAT,
-            /*data=*/ null);
-        GLError.maybeThrowGLException("Could not initialize LD cubemap mipmap", "glTexImage2D");
-      }
-    }
-  }
-
-  private Shader[] createShaders(SampleRender render, ChunkIterable chunks) throws IOException {
-    ImportanceSampleCacheEntry[][] importanceSampleCaches = generateImportanceSampleCaches();
-
-    HashMap<String, String> commonDefines = new HashMap<>();
-    commonDefines.put("NUMBER_OF_IMPORTANCE_SAMPLES", Integer.toString(numberOfImportanceSamples));
-    commonDefines.put("NUMBER_OF_MIPMAP_LEVELS", Integer.toString(numberOfMipmapLevels));
-
-    Shader[] shaders = new Shader[chunks.numberOfChunks];
-    for (Chunk chunk : chunks) {
-      HashMap<String, String> defines = new HashMap<>(commonDefines);
-      for (int location = 0; location < chunk.chunkSize; ++location) {
-        defines.put(
-            ATTACHMENT_LOCATION_DEFINES[chunk.firstFaceIndex + location],
-            Integer.toString(location));
-      }
-
-      // Create the shader and populate its uniforms with the importance sample cache entries.
-      shaders[chunk.chunkIndex] =
-          Shader.createFromAssets(
-                  render, "shaders/cubemap_filter.vert", "shaders/cubemap_filter.frag", defines)
-              .setTexture("u_Cubemap", radianceCubemap)
-              .setDepthTest(false)
-              .setDepthWrite(false);
-    }
-
-    for (Shader shader : shaders) {
-      for (int i = 0; i < importanceSampleCaches.length; ++i) {
-        ImportanceSampleCacheEntry[] cache = importanceSampleCaches[i];
-        String cacheName = "u_ImportanceSampleCaches[" + i + "]";
-        shader.setInt(cacheName + ".number_of_entries", cache.length);
-        for (int j = 0; j < cache.length; ++j) {
-          ImportanceSampleCacheEntry entry = cache[j];
-          String entryName = cacheName + ".entries[" + j + "]";
-          shader
-              .setVec3(entryName + ".direction", entry.direction)
-              .setFloat(entryName + ".contribution", entry.contribution)
-              .setFloat(entryName + ".level", entry.level);
-        }
-      }
-    }
-
-    return shaders;
-  }
-
-  private int[][] createFramebuffers(ChunkIterable chunks) {
-    // Create the framebuffers for each mipmap level.
-    int[][] framebuffers = new int[numberOfMipmapLevels][];
-    for (int level = 0; level < numberOfMipmapLevels; ++level) {
-      int[] framebufferChunks = new int[chunks.numberOfChunks];
-      GLES30.glGenFramebuffers(framebufferChunks.length, framebufferChunks, 0);
-      GLError.maybeThrowGLException("Could not create cubemap framebuffers", "glGenFramebuffers");
-      for (Chunk chunk : chunks) {
-        // Set the drawbuffers
-        GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, framebufferChunks[chunk.chunkIndex]);
-        GLError.maybeThrowGLException("Could not bind framebuffer", "glBindFramebuffer");
-        GLES30.glDrawBuffers(chunk.chunkSize, ATTACHMENT_ENUMS, 0);
-        GLError.maybeThrowGLException("Could not bind draw buffers", "glDrawBuffers");
-        // Since GLES doesn't support glFramebufferTexture, we will use each cubemap face as a
-        // different color attachment.
-        for (int attachment = 0; attachment < chunk.chunkSize; ++attachment) {
-          GLES30.glFramebufferTexture2D(
-              GLES30.GL_FRAMEBUFFER,
-              GLES30.GL_COLOR_ATTACHMENT0 + attachment,
-              GLES30.GL_TEXTURE_CUBE_MAP_POSITIVE_X + chunk.firstFaceIndex + attachment,
-              ldCubemap.getTextureId(),
-              level);
-          GLError.maybeThrowGLException(
-              "Could not attach LD cubemap mipmap to framebuffer", "glFramebufferTexture");
-        }
-      }
-      framebuffers[level] = framebufferChunks;
-    }
-
-    return framebuffers;
-  }
-
-  /**
-   * Generate a cache of importance sampling terms in tangent space, indexed by {@code
-   * [roughnessLevel-1][sampleIndex]}.
-   */
-  private ImportanceSampleCacheEntry[][] generateImportanceSampleCaches() {
-    ImportanceSampleCacheEntry[][] result =
-        new ImportanceSampleCacheEntry[numberOfMipmapLevels - 1][];
-    for (int i = 0; i < numberOfMipmapLevels - 1; ++i) {
-      int mipmapLevel = i + 1;
-      float perceptualRoughness = mipmapLevel / (float) (numberOfMipmapLevels - 1);
-      float roughness = perceptualRoughness * perceptualRoughness;
-      int resolution = this.resolution >> mipmapLevel;
-      float log4omegaP = log4((4.0f * PI_F) / (6 * resolution * resolution));
-      float inverseNumberOfSamples = 1f / numberOfImportanceSamples;
-
-      ArrayList<ImportanceSampleCacheEntry> cache = new ArrayList<>(numberOfImportanceSamples);
-      float weight = 0f;
-      for (int sampleIndex = 0; sampleIndex < numberOfImportanceSamples; ++sampleIndex) {
-        float[] u = hammersley(sampleIndex, inverseNumberOfSamples);
-        float[] h = hemisphereImportanceSampleDggx(u, roughness);
-        float noh = h[2];
-        float noh2 = noh * noh;
-        float nol = 2f * noh2 - 1f;
-        if (nol > 0) {
-          ImportanceSampleCacheEntry entry = new ImportanceSampleCacheEntry();
-          entry.direction = new float[] {2f * noh * h[0], 2 * noh * h[1], nol};
-          float pdf = distributionGgx(noh, roughness) / 4f;
-          float log4omegaS = log4(1f / (numberOfImportanceSamples * pdf));
-          // K is a LOD bias that allows a bit of overlapping between samples
-          float log4K = 1f; // K = 4
-          float l = log4omegaS - log4omegaP + log4K;
-          entry.level = min(max(l, 0f), (float) (numberOfMipmapLevels - 1));
-          entry.contribution = nol;
-
-          cache.add(entry);
-          weight += nol;
-        }
-      }
-      for (ImportanceSampleCacheEntry entry : cache) {
-        entry.contribution /= weight;
-      }
-      result[i] = new ImportanceSampleCacheEntry[cache.size()];
-      cache.toArray(result[i]);
-    }
-    return result;
-  }
-
-  private static int getMaxColorAttachments() {
-    int[] result = new int[1];
-    GLES30.glGetIntegerv(GLES30.GL_MAX_COLOR_ATTACHMENTS, result, 0);
-    GLError.maybeThrowGLException("Failed to get max color attachments", "glGetIntegerv");
-    return result[0];
-  }
-
-  // Math!
-  private static final float PI_F = (float) Math.PI;
-
-  private static int log2(int value) {
-    if (value <= 0) {
-      throw new IllegalArgumentException("value must be positive");
-    }
-    value >>= 1;
-    int result = 0;
-    while (value != 0) {
-      ++result;
-      value >>= 1;
-    }
-    return result;
-  }
-
-  private static float log4(float value) {
-    return (float) (Math.log((double) value) / Math.log(4.0));
-  }
-
-  private static float sqrt(float value) {
-    return (float) Math.sqrt((double) value);
-  }
-
-  private static float sin(float value) {
-    return (float) Math.sin((double) value);
-  }
-
-  private static float cos(float value) {
-    return (float) Math.cos((double) value);
-  }
-
-  private static float[] hammersley(int i, float iN) {
-    float tof = 0.5f / 0x80000000L;
-    long bits = i;
-    bits = (bits << 16) | (bits >>> 16);
-    bits = ((bits & 0x55555555L) << 1) | ((bits & 0xAAAAAAAAL) >>> 1);
-    bits = ((bits & 0x33333333L) << 2) | ((bits & 0xCCCCCCCCL) >>> 2);
-    bits = ((bits & 0x0F0F0F0FL) << 4) | ((bits & 0xF0F0F0F0L) >>> 4);
-    bits = ((bits & 0x00FF00FFL) << 8) | ((bits & 0xFF00FF00L) >>> 8);
-    return new float[] {i * iN, bits * tof};
-  }
-
-  private static float[] hemisphereImportanceSampleDggx(float[] u, float a) {
-    // GGX - Trowbridge-Reitz importance sampling
-    float phi = 2.0f * PI_F * u[0];
-    // NOTE: (aa-1) == (a-1)(a+1) produces better fp accuracy
-    float cosTheta2 = (1f - u[1]) / (1f + (a + 1f) * ((a - 1f) * u[1]));
-    float cosTheta = sqrt(cosTheta2);
-    float sinTheta = sqrt(1f - cosTheta2);
-    return new float[] {sinTheta * cos(phi), sinTheta * sin(phi), cosTheta};
-  }
-
-  private static float distributionGgx(float noh, float a) {
-    // NOTE: (aa-1) == (a-1)(a+1) produces better fp accuracy
-    float f = (a - 1f) * ((a + 1f) * (noh * noh)) + 1f;
-    return (a * a) / (PI_F * f * f);
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/EisSettings.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/EisSettings.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/EisSettings.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/EisSettings.java	
+++ /dev/null	
@@ -1,53 +0,0 @@
-/*
- * Copyright 2023 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-
-/**
- * A class providing persistent EIS preference across instances using {@code
- * android.content.SharedPreferences}.
- */
-public class EisSettings {
-  public static final String SHARED_PREFERENCE_ID = "SHARED_PREFERENCE_EIS_OPTIONS";
-  public static final String SHARED_PREFERENCE_EIS_ENABLED = "eis_enabled";
-  private boolean eisEnabled = false;
-  private SharedPreferences sharedPreferences;
-
-  /** Creates shared preference entry for EIS setting. */
-  public void onCreate(Context context) {
-    sharedPreferences = context.getSharedPreferences(SHARED_PREFERENCE_ID, Context.MODE_PRIVATE);
-    eisEnabled = sharedPreferences.getBoolean(SHARED_PREFERENCE_EIS_ENABLED, false);
-  }
-
-  /** Returns saved EIS state. */
-  public boolean isEisEnabled() {
-    return eisEnabled;
-  }
-
-  /** Sets and saves the EIS using {@code android.content.SharedPreferences} */
-  public void setEisEnabled(boolean enable) {
-    if (enable == eisEnabled) {
-      return;
-    }
-
-    eisEnabled = enable;
-    SharedPreferences.Editor editor = sharedPreferences.edit();
-    editor.putBoolean(SHARED_PREFERENCE_EIS_ENABLED, eisEnabled);
-    editor.apply();
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/Shader.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Shader.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Shader.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Shader.java	
+++ /dev/null	
@@ -1,669 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-import android.content.res.AssetManager;
-import android.opengl.GLES30;
-import android.opengl.GLException;
-import android.util.Log;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.regex.Matcher;
-
-/**
- * Represents a GPU shader, the state of its associated uniforms, and some additional draw state.
- */
-public class Shader implements Closeable {
-  private static final String TAG = Shader.class.getSimpleName();
-
-  /**
-   * A factor to be used in a blend function.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glBlendFunc.xhtml">glBlendFunc</a>
-   */
-  public static enum BlendFactor {
-    ZERO(GLES30.GL_ZERO),
-    ONE(GLES30.GL_ONE),
-    SRC_COLOR(GLES30.GL_SRC_COLOR),
-    ONE_MINUS_SRC_COLOR(GLES30.GL_ONE_MINUS_SRC_COLOR),
-    DST_COLOR(GLES30.GL_DST_COLOR),
-    ONE_MINUS_DST_COLOR(GLES30.GL_ONE_MINUS_DST_COLOR),
-    SRC_ALPHA(GLES30.GL_SRC_ALPHA),
-    ONE_MINUS_SRC_ALPHA(GLES30.GL_ONE_MINUS_SRC_ALPHA),
-    DST_ALPHA(GLES30.GL_DST_ALPHA),
-    ONE_MINUS_DST_ALPHA(GLES30.GL_ONE_MINUS_DST_ALPHA),
-    CONSTANT_COLOR(GLES30.GL_CONSTANT_COLOR),
-    ONE_MINUS_CONSTANT_COLOR(GLES30.GL_ONE_MINUS_CONSTANT_COLOR),
-    CONSTANT_ALPHA(GLES30.GL_CONSTANT_ALPHA),
-    ONE_MINUS_CONSTANT_ALPHA(GLES30.GL_ONE_MINUS_CONSTANT_ALPHA);
-
-    /* package-private */
-    final int glesEnum;
-
-    private BlendFactor(int glesEnum) {
-      this.glesEnum = glesEnum;
-    }
-  }
-
-  private int programId = 0;
-  private final Map<Integer, Uniform> uniforms = new HashMap<>();
-  private int maxTextureUnit = 0;
-
-  private final Map<String, Integer> uniformLocations = new HashMap<>();
-  private final Map<Integer, String> uniformNames = new HashMap<>();
-
-  private boolean depthTest = true;
-  private boolean depthWrite = true;
-  private boolean cullFace = true;
-  private BlendFactor sourceRgbBlend = BlendFactor.ONE;
-  private BlendFactor destRgbBlend = BlendFactor.ZERO;
-  private BlendFactor sourceAlphaBlend = BlendFactor.ONE;
-  private BlendFactor destAlphaBlend = BlendFactor.ZERO;
-
-  /**
-   * Constructs a {@link Shader} given the shader code.
-   *
-   * @param defines A map of shader precompiler symbols to be defined with the given names and
-   *     values
-   */
-  public Shader(
-      SampleRender render,
-      String vertexShaderCode,
-      String fragmentShaderCode,
-      Map<String, String> defines) {
-    int vertexShaderId = 0;
-    int fragmentShaderId = 0;
-    String definesCode = createShaderDefinesCode(defines);
-    try {
-      vertexShaderId =
-          createShader(
-              GLES30.GL_VERTEX_SHADER, insertShaderDefinesCode(vertexShaderCode, definesCode));
-      fragmentShaderId =
-          createShader(
-              GLES30.GL_FRAGMENT_SHADER, insertShaderDefinesCode(fragmentShaderCode, definesCode));
-
-      programId = GLES30.glCreateProgram();
-      GLError.maybeThrowGLException("Shader program creation failed", "glCreateProgram");
-      GLES30.glAttachShader(programId, vertexShaderId);
-      GLError.maybeThrowGLException("Failed to attach vertex shader", "glAttachShader");
-      GLES30.glAttachShader(programId, fragmentShaderId);
-      GLError.maybeThrowGLException("Failed to attach fragment shader", "glAttachShader");
-      GLES30.glLinkProgram(programId);
-      GLError.maybeThrowGLException("Failed to link shader program", "glLinkProgram");
-
-      final int[] linkStatus = new int[1];
-      GLES30.glGetProgramiv(programId, GLES30.GL_LINK_STATUS, linkStatus, 0);
-      if (linkStatus[0] == GLES30.GL_FALSE) {
-        String infoLog = GLES30.glGetProgramInfoLog(programId);
-        GLError.maybeLogGLError(
-            Log.WARN, TAG, "Failed to retrieve shader program info log", "glGetProgramInfoLog");
-        throw new GLException(0, "Shader link failed: " + infoLog);
-      }
-    } catch (Throwable t) {
-      close();
-      throw t;
-    } finally {
-      // Shader objects can be flagged for deletion immediately after program creation.
-      if (vertexShaderId != 0) {
-        GLES30.glDeleteShader(vertexShaderId);
-        GLError.maybeLogGLError(Log.WARN, TAG, "Failed to free vertex shader", "glDeleteShader");
-      }
-      if (fragmentShaderId != 0) {
-        GLES30.glDeleteShader(fragmentShaderId);
-        GLError.maybeLogGLError(Log.WARN, TAG, "Failed to free fragment shader", "glDeleteShader");
-      }
-    }
-  }
-
-  /**
-   * Creates a {@link Shader} from the given asset file names.
-   *
-   * <p>The file contents are interpreted as UTF-8 text.
-   *
-   * @param defines A map of shader precompiler symbols to be defined with the given names and
-   *     values
-   */
-  public static Shader createFromAssets(
-      SampleRender render,
-      String vertexShaderFileName,
-      String fragmentShaderFileName,
-      Map<String, String> defines)
-      throws IOException {
-    AssetManager assets = render.getAssets();
-    return new Shader(
-        render,
-        inputStreamToString(assets.open(vertexShaderFileName)),
-        inputStreamToString(assets.open(fragmentShaderFileName)),
-        defines);
-  }
-
-  @Override
-  public void close() {
-    if (programId != 0) {
-      GLES30.glDeleteProgram(programId);
-      programId = 0;
-    }
-  }
-
-  /**
-   * Sets depth test state.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glEnable.xhtml">glEnable(GL_DEPTH_TEST)</a>.
-   */
-  public Shader setDepthTest(boolean depthTest) {
-    this.depthTest = depthTest;
-    return this;
-  }
-
-  /**
-   * Sets depth write state.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glDepthMask.xhtml">glDepthMask</a>.
-   */
-  public Shader setDepthWrite(boolean depthWrite) {
-    this.depthWrite = depthWrite;
-    return this;
-  }
-
-  /**
-   * Sets cull face state.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glEnable.xhtml">glEnable(GL_CULL_FACE)</a>.
-   */
-  public Shader setCullFace(boolean cullFace) {
-    this.cullFace = cullFace;
-    return this;
-  }
-
-  /**
-   * Sets blending function.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml">glBlendFunc</a>
-   */
-  public Shader setBlend(BlendFactor sourceBlend, BlendFactor destBlend) {
-    this.sourceRgbBlend = sourceBlend;
-    this.destRgbBlend = destBlend;
-    this.sourceAlphaBlend = sourceBlend;
-    this.destAlphaBlend = destBlend;
-    return this;
-  }
-
-  /**
-   * Sets blending functions separately for RGB and alpha channels.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glBlendFuncSeparate.xhtml">glBlendFunc</a>
-   */
-  public Shader setBlend(
-      BlendFactor sourceRgbBlend,
-      BlendFactor destRgbBlend,
-      BlendFactor sourceAlphaBlend,
-      BlendFactor destAlphaBlend) {
-    this.sourceRgbBlend = sourceRgbBlend;
-    this.destRgbBlend = destRgbBlend;
-    this.sourceAlphaBlend = sourceAlphaBlend;
-    this.destAlphaBlend = destAlphaBlend;
-    return this;
-  }
-
-  /** Sets a texture uniform. */
-  public Shader setTexture(String name, Texture texture) {
-    // Special handling for Textures. If replacing an existing texture uniform, reuse the texture
-    // unit.
-    int location = getUniformLocation(name);
-    Uniform uniform = uniforms.get(location);
-    int textureUnit;
-    if (!(uniform instanceof UniformTexture)) {
-      textureUnit = maxTextureUnit++;
-    } else {
-      UniformTexture uniformTexture = (UniformTexture) uniform;
-      textureUnit = uniformTexture.getTextureUnit();
-    }
-    uniforms.put(location, new UniformTexture(textureUnit, texture));
-    return this;
-  }
-
-  /** Sets a {@code bool} uniform. */
-  public Shader setBool(String name, boolean v0) {
-    int[] values = {v0 ? 1 : 0};
-    uniforms.put(getUniformLocation(name), new UniformInt(values));
-    return this;
-  }
-
-  /** Sets an {@code int} uniform. */
-  public Shader setInt(String name, int v0) {
-    int[] values = {v0};
-    uniforms.put(getUniformLocation(name), new UniformInt(values));
-    return this;
-  }
-
-  /** Sets a {@code float} uniform. */
-  public Shader setFloat(String name, float v0) {
-    float[] values = {v0};
-    uniforms.put(getUniformLocation(name), new Uniform1f(values));
-    return this;
-  }
-
-  /** Sets a {@code vec2} uniform. */
-  public Shader setVec2(String name, float[] values) {
-    if (values.length != 2) {
-      throw new IllegalArgumentException("Value array length must be 2");
-    }
-    uniforms.put(getUniformLocation(name), new Uniform2f(values.clone()));
-    return this;
-  }
-  /** Sets a {@code vec3} uniform. */
-  public Shader setVec3(String name, float[] values) {
-    if (values.length != 3) {
-      throw new IllegalArgumentException("Value array length must be 3");
-    }
-    uniforms.put(getUniformLocation(name), new Uniform3f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code vec4} uniform. */
-  public Shader setVec4(String name, float[] values) {
-    if (values.length != 4) {
-      throw new IllegalArgumentException("Value array length must be 4");
-    }
-    uniforms.put(getUniformLocation(name), new Uniform4f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code mat2} uniform. */
-  public Shader setMat2(String name, float[] values) {
-    if (values.length != 4) {
-      throw new IllegalArgumentException("Value array length must be 4 (2x2)");
-    }
-    uniforms.put(getUniformLocation(name), new UniformMatrix2f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code mat3} uniform. */
-  public Shader setMat3(String name, float[] values) {
-    if (values.length != 9) {
-      throw new IllegalArgumentException("Value array length must be 9 (3x3)");
-    }
-    uniforms.put(getUniformLocation(name), new UniformMatrix3f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code mat4} uniform. */
-  public Shader setMat4(String name, float[] values) {
-    if (values.length != 16) {
-      throw new IllegalArgumentException("Value array length must be 16 (4x4)");
-    }
-    uniforms.put(getUniformLocation(name), new UniformMatrix4f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code bool} array uniform. */
-  public Shader setBoolArray(String name, boolean[] values) {
-    int[] intValues = new int[values.length];
-    for (int i = 0; i < values.length; ++i) {
-      intValues[i] = values[i] ? 1 : 0;
-    }
-    uniforms.put(getUniformLocation(name), new UniformInt(intValues));
-    return this;
-  }
-
-  /** Sets an {@code int} array uniform. */
-  public Shader setIntArray(String name, int[] values) {
-    uniforms.put(getUniformLocation(name), new UniformInt(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code float} array uniform. */
-  public Shader setFloatArray(String name, float[] values) {
-    uniforms.put(getUniformLocation(name), new Uniform1f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code vec2} array uniform. */
-  public Shader setVec2Array(String name, float[] values) {
-    if (values.length % 2 != 0) {
-      throw new IllegalArgumentException("Value array length must be divisible by 2");
-    }
-    uniforms.put(getUniformLocation(name), new Uniform2f(values.clone()));
-    return this;
-  }
-  /** Sets a {@code vec3} array uniform. */
-  public Shader setVec3Array(String name, float[] values) {
-    if (values.length % 3 != 0) {
-      throw new IllegalArgumentException("Value array length must be divisible by 3");
-    }
-    uniforms.put(getUniformLocation(name), new Uniform3f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code vec4} array uniform. */
-  public Shader setVec4Array(String name, float[] values) {
-    if (values.length % 4 != 0) {
-      throw new IllegalArgumentException("Value array length must be divisible by 4");
-    }
-    uniforms.put(getUniformLocation(name), new Uniform4f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code mat2} array uniform. */
-  public Shader setMat2Array(String name, float[] values) {
-    if (values.length % 4 != 0) {
-      throw new IllegalArgumentException("Value array length must be divisible by 4 (2x2)");
-    }
-    uniforms.put(getUniformLocation(name), new UniformMatrix2f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code mat3} array uniform. */
-  public Shader setMat3Array(String name, float[] values) {
-    if (values.length % 9 != 0) {
-      throw new IllegalArgumentException("Values array length must be divisible by 9 (3x3)");
-    }
-    uniforms.put(getUniformLocation(name), new UniformMatrix3f(values.clone()));
-    return this;
-  }
-
-  /** Sets a {@code mat4} uniform. */
-  public Shader setMat4Array(String name, float[] values) {
-    if (values.length % 16 != 0) {
-      throw new IllegalArgumentException("Value array length must be divisible by 16 (4x4)");
-    }
-    uniforms.put(getUniformLocation(name), new UniformMatrix4f(values.clone()));
-    return this;
-  }
-
-  /**
-   * Activates the shader. Don't call this directly unless you are doing low level OpenGL code;
-   * instead, prefer {@link SampleRender#draw}.
-   */
-  public void lowLevelUse() {
-    // Make active shader/set uniforms
-    if (programId == 0) {
-      throw new IllegalStateException("Attempted to use freed shader");
-    }
-    GLES30.glUseProgram(programId);
-    GLError.maybeThrowGLException("Failed to use shader program", "glUseProgram");
-    GLES30.glBlendFuncSeparate(
-        sourceRgbBlend.glesEnum,
-        destRgbBlend.glesEnum,
-        sourceAlphaBlend.glesEnum,
-        destAlphaBlend.glesEnum);
-    GLError.maybeThrowGLException("Failed to set blend mode", "glBlendFuncSeparate");
-    GLES30.glDepthMask(depthWrite);
-    GLError.maybeThrowGLException("Failed to set depth write mask", "glDepthMask");
-    if (depthTest) {
-      GLES30.glEnable(GLES30.GL_DEPTH_TEST);
-      GLError.maybeThrowGLException("Failed to enable depth test", "glEnable");
-    } else {
-      GLES30.glDisable(GLES30.GL_DEPTH_TEST);
-      GLError.maybeThrowGLException("Failed to disable depth test", "glDisable");
-    }
-    if (cullFace) {
-      GLES30.glEnable(GLES30.GL_CULL_FACE);
-      GLError.maybeThrowGLException("Failed to enable backface culling", "glEnable");
-    } else {
-      GLES30.glDisable(GLES30.GL_CULL_FACE);
-      GLError.maybeThrowGLException("Failed to disable backface culling", "glDisable");
-    }
-    try {
-      // Remove all non-texture uniforms from the map after setting them, since they're stored as
-      // part of the program.
-      ArrayList<Integer> obsoleteEntries = new ArrayList<>(uniforms.size());
-      for (Map.Entry<Integer, Uniform> entry : uniforms.entrySet()) {
-        try {
-          entry.getValue().use(entry.getKey());
-          if (!(entry.getValue() instanceof UniformTexture)) {
-            obsoleteEntries.add(entry.getKey());
-          }
-        } catch (GLException e) {
-          String name = uniformNames.get(entry.getKey());
-          throw new IllegalArgumentException("Error setting uniform `" + name + "'", e);
-        }
-      }
-      uniforms.keySet().removeAll(obsoleteEntries);
-    } finally {
-      GLES30.glActiveTexture(GLES30.GL_TEXTURE0);
-      GLError.maybeLogGLError(Log.WARN, TAG, "Failed to set active texture", "glActiveTexture");
-    }
-  }
-
-  private static interface Uniform {
-    public void use(int location);
-  }
-
-  private static class UniformTexture implements Uniform {
-    private final int textureUnit;
-    private final Texture texture;
-
-    public UniformTexture(int textureUnit, Texture texture) {
-      this.textureUnit = textureUnit;
-      this.texture = texture;
-    }
-
-    public int getTextureUnit() {
-      return textureUnit;
-    }
-
-    @Override
-    public void use(int location) {
-      if (texture.getTextureId() == 0) {
-        throw new IllegalStateException("Tried to draw with freed texture");
-      }
-      GLES30.glActiveTexture(GLES30.GL_TEXTURE0 + textureUnit);
-      GLError.maybeThrowGLException("Failed to set active texture", "glActiveTexture");
-      GLES30.glBindTexture(texture.getTarget().glesEnum, texture.getTextureId());
-      GLError.maybeThrowGLException("Failed to bind texture", "glBindTexture");
-      GLES30.glUniform1i(location, textureUnit);
-      GLError.maybeThrowGLException("Failed to set shader texture uniform", "glUniform1i");
-    }
-  }
-
-  private static class UniformInt implements Uniform {
-    private final int[] values;
-
-    public UniformInt(int[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniform1iv(location, values.length, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform 1i", "glUniform1iv");
-    }
-  }
-
-  private static class Uniform1f implements Uniform {
-    private final float[] values;
-
-    public Uniform1f(float[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniform1fv(location, values.length, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform 1f", "glUniform1fv");
-    }
-  }
-
-  private static class Uniform2f implements Uniform {
-    private final float[] values;
-
-    public Uniform2f(float[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniform2fv(location, values.length / 2, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform 2f", "glUniform2fv");
-    }
-  }
-
-  private static class Uniform3f implements Uniform {
-    private final float[] values;
-
-    public Uniform3f(float[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniform3fv(location, values.length / 3, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform 3f", "glUniform3fv");
-    }
-  }
-
-  private static class Uniform4f implements Uniform {
-    private final float[] values;
-
-    public Uniform4f(float[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniform4fv(location, values.length / 4, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform 4f", "glUniform4fv");
-    }
-  }
-
-  private static class UniformMatrix2f implements Uniform {
-    private final float[] values;
-
-    public UniformMatrix2f(float[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniformMatrix2fv(location, values.length / 4, /*transpose=*/ false, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform matrix 2f", "glUniformMatrix2fv");
-    }
-  }
-
-  private static class UniformMatrix3f implements Uniform {
-    private final float[] values;
-
-    public UniformMatrix3f(float[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniformMatrix3fv(location, values.length / 9, /*transpose=*/ false, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform matrix 3f", "glUniformMatrix3fv");
-    }
-  }
-
-  private static class UniformMatrix4f implements Uniform {
-    private final float[] values;
-
-    public UniformMatrix4f(float[] values) {
-      this.values = values;
-    }
-
-    @Override
-    public void use(int location) {
-      GLES30.glUniformMatrix4fv(location, values.length / 16, /*transpose=*/ false, values, 0);
-      GLError.maybeThrowGLException("Failed to set shader uniform matrix 4f", "glUniformMatrix4fv");
-    }
-  }
-
-  private int getUniformLocation(String name) {
-    Integer locationObject = uniformLocations.get(name);
-    if (locationObject != null) {
-      return locationObject;
-    }
-    int location = GLES30.glGetUniformLocation(programId, name);
-    GLError.maybeThrowGLException("Failed to find uniform", "glGetUniformLocation");
-    if (location == -1) {
-      throw new IllegalArgumentException("Shader uniform does not exist: " + name);
-    }
-    uniformLocations.put(name, Integer.valueOf(location));
-    uniformNames.put(Integer.valueOf(location), name);
-    return location;
-  }
-
-  private static int createShader(int type, String code) {
-    int shaderId = GLES30.glCreateShader(type);
-    GLError.maybeThrowGLException("Shader creation failed", "glCreateShader");
-    GLES30.glShaderSource(shaderId, code);
-    GLError.maybeThrowGLException("Shader source failed", "glShaderSource");
-    GLES30.glCompileShader(shaderId);
-    GLError.maybeThrowGLException("Shader compilation failed", "glCompileShader");
-
-    final int[] compileStatus = new int[1];
-    GLES30.glGetShaderiv(shaderId, GLES30.GL_COMPILE_STATUS, compileStatus, 0);
-    if (compileStatus[0] == GLES30.GL_FALSE) {
-      String infoLog = GLES30.glGetShaderInfoLog(shaderId);
-      GLError.maybeLogGLError(
-          Log.WARN, TAG, "Failed to retrieve shader info log", "glGetShaderInfoLog");
-      GLES30.glDeleteShader(shaderId);
-      GLError.maybeLogGLError(Log.WARN, TAG, "Failed to free shader", "glDeleteShader");
-      throw new GLException(0, "Shader compilation failed: " + infoLog);
-    }
-
-    return shaderId;
-  }
-
-  private static String createShaderDefinesCode(Map<String, String> defines) {
-    if (defines == null) {
-      return "";
-    }
-    StringBuilder builder = new StringBuilder();
-    for (Map.Entry<String, String> entry : defines.entrySet()) {
-      builder.append("#define " + entry.getKey() + " " + entry.getValue() + "\n");
-    }
-    return builder.toString();
-  }
-
-  private static String insertShaderDefinesCode(String sourceCode, String definesCode) {
-    String result =
-        sourceCode.replaceAll(
-            "(?m)^(\\s*#\\s*version\\s+.*)$", "$1\n" + Matcher.quoteReplacement(definesCode));
-    if (result.equals(sourceCode)) {
-      // No #version specified, so just prepend source
-      return definesCode + sourceCode;
-    }
-    return result;
-  }
-
-  private static String inputStreamToString(InputStream stream) throws IOException {
-    InputStreamReader reader = new InputStreamReader(stream, UTF_8.name());
-    char[] buffer = new char[1024 * 4];
-    StringBuilder builder = new StringBuilder();
-    int amount = 0;
-    while ((amount = reader.read(buffer)) != -1) {
-      builder.append(buffer, 0, amount);
-    }
-    reader.close();
-    return builder.toString();
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/BackgroundRenderer.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/BackgroundRenderer.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/BackgroundRenderer.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/BackgroundRenderer.java	
+++ /dev/null	
@@ -1,263 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender.arcore;
-
-import android.media.Image;
-import android.opengl.GLES30;
-
-import com.example.memotion.arcamera.common.samplerender.Framebuffer;
-import com.example.memotion.arcamera.common.samplerender.Mesh;
-import com.example.memotion.arcamera.common.samplerender.SampleRender;
-import com.example.memotion.arcamera.common.samplerender.Shader;
-import com.example.memotion.arcamera.common.samplerender.Texture;
-import com.example.memotion.arcamera.common.samplerender.VertexBuffer;
-import com.google.ar.core.Coordinates2d;
-import com.google.ar.core.Frame;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-import java.util.HashMap;
-
-/**
- * This class both renders the AR camera background and composes the a scene foreground. The camera
- * background can be rendered as either camera image data or camera depth data. The virtual scene
- * can be composited with or without depth occlusion.
- */
-public class BackgroundRenderer {
-  private static final String TAG = BackgroundRenderer.class.getSimpleName();
-
-  // components_per_vertex * number_of_vertices * float_size
-  private static final int COORDS_BUFFER_SIZE = 2 * 4 * 4;
-
-  private static final FloatBuffer NDC_QUAD_COORDS_BUFFER =
-      ByteBuffer.allocateDirect(COORDS_BUFFER_SIZE).order(ByteOrder.nativeOrder()).asFloatBuffer();
-
-  private static final FloatBuffer VIRTUAL_SCENE_TEX_COORDS_BUFFER =
-      ByteBuffer.allocateDirect(COORDS_BUFFER_SIZE).order(ByteOrder.nativeOrder()).asFloatBuffer();
-
-  static {
-    NDC_QUAD_COORDS_BUFFER.put(
-        new float[] {
-          /*0:*/ -1f, -1f, /*1:*/ +1f, -1f, /*2:*/ -1f, +1f, /*3:*/ +1f, +1f,
-        });
-    VIRTUAL_SCENE_TEX_COORDS_BUFFER.put(
-        new float[] {
-          /*0:*/ 0f, 0f, /*1:*/ 1f, 0f, /*2:*/ 0f, 1f, /*3:*/ 1f, 1f,
-        });
-  }
-
-  private final FloatBuffer cameraTexCoords =
-      ByteBuffer.allocateDirect(COORDS_BUFFER_SIZE).order(ByteOrder.nativeOrder()).asFloatBuffer();
-
-  private final Mesh mesh;
-  private final VertexBuffer cameraTexCoordsVertexBuffer;
-  private Shader backgroundShader;
-  private Shader occlusionShader;
-  private final Texture cameraDepthTexture;
-  private final Texture cameraColorTexture;
-  private Texture depthColorPaletteTexture;
-
-  private boolean useDepthVisualization;
-  private boolean useOcclusion;
-  private float aspectRatio;
-
-//  /**
-//   * Allocates and initializes OpenGL resources needed by the background renderer. Must be called
-//   * during a {@link SampleRender.Renderer} callback, typically in {@link
-//   * SampleRender.Renderer#onSurfaceCreated()}.
-//   */
-  public BackgroundRenderer(SampleRender render) {
-    cameraColorTexture =
-        new Texture(
-            render,
-            Texture.Target.TEXTURE_EXTERNAL_OES,
-            Texture.WrapMode.CLAMP_TO_EDGE,
-            /*useMipmaps=*/ false);
-    cameraDepthTexture =
-        new Texture(
-            render,
-            Texture.Target.TEXTURE_2D,
-            Texture.WrapMode.CLAMP_TO_EDGE,
-            /*useMipmaps=*/ false);
-
-    // Create a Mesh with three vertex buffers: one for the screen coordinates (normalized device
-    // coordinates), one for the camera texture coordinates (to be populated with proper data later
-    // before drawing), and one for the virtual scene texture coordinates (unit texture quad)
-    VertexBuffer screenCoordsVertexBuffer =
-        new VertexBuffer(render, /* numberOfEntriesPerVertex=*/ 2, NDC_QUAD_COORDS_BUFFER);
-    cameraTexCoordsVertexBuffer =
-        new VertexBuffer(render, /*numberOfEntriesPerVertex=*/ 2, /*entries=*/ null);
-    VertexBuffer virtualSceneTexCoordsVertexBuffer =
-        new VertexBuffer(render, /* numberOfEntriesPerVertex=*/ 2, VIRTUAL_SCENE_TEX_COORDS_BUFFER);
-    VertexBuffer[] vertexBuffers = {
-      screenCoordsVertexBuffer, cameraTexCoordsVertexBuffer, virtualSceneTexCoordsVertexBuffer,
-    };
-    mesh =
-        new Mesh(render, Mesh.PrimitiveMode.TRIANGLE_STRIP, /*indexBuffer=*/ null, vertexBuffers);
-  }
-
-  /**
-   * Sets whether the background camera image should be replaced with a depth visualization instead.
-   * This reloads the corresponding shader code, and must be called on the GL thread.
-   */
-  public void setUseDepthVisualization(SampleRender render, boolean useDepthVisualization)
-      throws IOException {
-    if (backgroundShader != null) {
-      if (this.useDepthVisualization == useDepthVisualization) {
-        return;
-      }
-      backgroundShader.close();
-      backgroundShader = null;
-      this.useDepthVisualization = useDepthVisualization;
-    }
-    if (useDepthVisualization) {
-     depthColorPaletteTexture =
-        Texture.createFromAsset(
-            render,
-            "models/depth_color_palette.png",
-            Texture.WrapMode.CLAMP_TO_EDGE,
-            Texture.ColorFormat.LINEAR);
-      backgroundShader =
-          Shader.createFromAssets(
-                  render,
-                  "shaders/background_show_depth_color_visualization.vert",
-                  "shaders/background_show_depth_color_visualization.frag",
-                  /*defines=*/ null)
-              .setTexture("u_CameraDepthTexture", cameraDepthTexture)
-              .setTexture("u_ColorMap", depthColorPaletteTexture)
-              .setDepthTest(false)
-              .setDepthWrite(false);
-    } else {
-      backgroundShader =
-          Shader.createFromAssets(
-                  render,
-                  "shaders/background_show_camera.vert",
-                  "shaders/background_show_camera.frag",
-                  /*defines=*/ null)
-              .setTexture("u_CameraColorTexture", cameraColorTexture)
-              .setDepthTest(false)
-              .setDepthWrite(false);
-    }
-  }
-
-  /**
-   * Sets whether to use depth for occlusion. This reloads the shader code with new {@code
-   * #define}s, and must be called on the GL thread.
-   */
-  public void setUseOcclusion(SampleRender render, boolean useOcclusion) throws IOException {
-    if (occlusionShader != null) {
-      if (this.useOcclusion == useOcclusion) {
-        return;
-      }
-      occlusionShader.close();
-      occlusionShader = null;
-      this.useOcclusion = useOcclusion;
-    }
-    HashMap<String, String> defines = new HashMap<>();
-    defines.put("USE_OCCLUSION", useOcclusion ? "1" : "0");
-    occlusionShader =
-        Shader.createFromAssets(render, "shaders/occlusion.vert", "shaders/occlusion.frag", defines)
-            .setDepthTest(false)
-            .setDepthWrite(false)
-            .setBlend(Shader.BlendFactor.SRC_ALPHA, Shader.BlendFactor.ONE_MINUS_SRC_ALPHA);
-    if (useOcclusion) {
-      occlusionShader
-          .setTexture("u_CameraDepthTexture", cameraDepthTexture)
-          .setFloat("u_DepthAspectRatio", aspectRatio);
-    }
-  }
-
-//  /**
-//   * Updates the display geometry. This must be called every frame before calling either of
-//   * BackgroundRenderer's draw methods.
-//   *
-//   * @param frame The current {@code Frame} as returned by {@link Session#update()}.
-//   */
-  public void updateDisplayGeometry(Frame frame) {
-    if (frame.hasDisplayGeometryChanged()) {
-      // If display rotation changed (also includes view size change), we need to re-query the UV
-      // coordinates for the screen rect, as they may have changed as well.
-      frame.transformCoordinates2d(
-          Coordinates2d.OPENGL_NORMALIZED_DEVICE_COORDINATES,
-          NDC_QUAD_COORDS_BUFFER,
-          Coordinates2d.TEXTURE_NORMALIZED,
-          cameraTexCoords);
-      cameraTexCoordsVertexBuffer.set(cameraTexCoords);
-    }
-  }
-
-  /** Update depth texture with Image contents. */
-  public void updateCameraDepthTexture(Image image) {
-    // SampleRender abstraction leaks here
-    GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, cameraDepthTexture.getTextureId());
-    GLES30.glTexImage2D(
-        GLES30.GL_TEXTURE_2D,
-        0,
-        GLES30.GL_RG8,
-        image.getWidth(),
-        image.getHeight(),
-        0,
-        GLES30.GL_RG,
-        GLES30.GL_UNSIGNED_BYTE,
-        image.getPlanes()[0].getBuffer());
-    if (useOcclusion) {
-      aspectRatio = (float) image.getWidth() / (float) image.getHeight();
-      occlusionShader.setFloat("u_DepthAspectRatio", aspectRatio);
-    }
-  }
-
-  /**
-   * Draws the AR background image. The image will be drawn such that virtual content rendered with
-   * the matrices provided by {@link com.google.ar.core.Camera#getViewMatrix(float[], int)} and
-   * accurately follow static physical objects.
-   */
-  public void drawBackground(SampleRender render) {
-    render.draw(mesh, backgroundShader);
-  }
-
-//  /**
-//   * Draws the virtual scene. Any objects rendered in the given {@link Framebuffer} will be drawn
-//   * given the previously specified {@link OcclusionMode}.
-//   *
-//   * <p>Virtual content should be rendered using the matrices provided by {@link
-//   * com.google.ar.core.Camera#getViewMatrix(float[], int)} and {@link
-//   * com.google.ar.core.Camera#getProjectionMatrix(float[], int, float, float)}.
-//   */
-  public void drawVirtualScene(
-      SampleRender render, Framebuffer virtualSceneFramebuffer, float zNear, float zFar) {
-    occlusionShader.setTexture(
-        "u_VirtualSceneColorTexture", virtualSceneFramebuffer.getColorTexture());
-    if (useOcclusion) {
-      occlusionShader
-          .setTexture("u_VirtualSceneDepthTexture", virtualSceneFramebuffer.getDepthTexture())
-          .setFloat("u_ZNear", zNear)
-          .setFloat("u_ZFar", zFar);
-    }
-    render.draw(mesh, occlusionShader);
-  }
-
-  /** Return the camera color texture generated by this object. */
-  public Texture getCameraColorTexture() {
-    return cameraColorTexture;
-  }
-
-  /** Return the camera depth texture generated by this object. */
-  public Texture getCameraDepthTexture() {
-    return cameraDepthTexture;
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/IndexBuffer.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/IndexBuffer.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/IndexBuffer.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/IndexBuffer.java	
+++ /dev/null	
@@ -1,78 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.opengl.GLES30;
-
-import java.io.Closeable;
-import java.nio.IntBuffer;
-
-/**
- * A list of vertex indices stored GPU-side.
- *
- * <p>When constructing a {@link Mesh}, an {@link IndexBuffer} may be passed to describe the
- * ordering of vertices when drawing each primitive.
- *
- * @see <a
- *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glDrawElements.xhtml">glDrawElements</a>
- */
-public class IndexBuffer implements Closeable {
-  private final GpuBuffer buffer;
-
-  /**
-   * Construct an {@link IndexBuffer} populated with initial data.
-   *
-   * <p>The GPU buffer will be filled with the data in the <i>direct</i> buffer {@code entries},
-   * starting from the beginning of the buffer (not the current cursor position). The cursor will be
-   * left in an undefined position after this function returns.
-   *
-   * <p>The {@code entries} buffer may be null, in which case an empty buffer is constructed
-   * instead.
-   */
-  public IndexBuffer(SampleRender render, IntBuffer entries) {
-    buffer = new GpuBuffer(GLES30.GL_ELEMENT_ARRAY_BUFFER, GpuBuffer.INT_SIZE, entries);
-  }
-
-  /**
-   * Populate with new data.
-   *
-   * <p>The entire buffer is replaced by the contents of the <i>direct</i> buffer {@code entries}
-   * starting from the beginning of the buffer, not the current cursor position. The cursor will be
-   * left in an undefined position after this function returns.
-   *
-   * <p>The GPU buffer is reallocated automatically if necessary.
-   *
-   * <p>The {@code entries} buffer may be null, in which case the buffer will become empty.
-   */
-  public void set(IntBuffer entries) {
-    buffer.set(entries);
-  }
-
-  @Override
-  public void close() {
-    buffer.free();
-  }
-
-  /* package-private */
-  int getBufferId() {
-    return buffer.getBufferId();
-  }
-
-  /* package-private */
-  int getSize() {
-    return buffer.getSize();
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/DisplayRotationHelper.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/DisplayRotationHelper.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/DisplayRotationHelper.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/DisplayRotationHelper.java	
+++ /dev/null	
@@ -1,166 +0,0 @@
-/*
- * Copyright 2017 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.app.Activity;
-import android.content.Context;
-import android.hardware.camera2.CameraAccessException;
-import android.hardware.camera2.CameraCharacteristics;
-import android.hardware.camera2.CameraManager;
-import android.hardware.display.DisplayManager;
-import android.hardware.display.DisplayManager.DisplayListener;
-import android.view.Display;
-import android.view.Surface;
-import android.view.WindowManager;
-
-import com.google.ar.core.Session;
-
-/**
- * Helper to track the display rotations. In particular, the 180 degree rotations are not notified
- * by the onSurfaceChanged() callback, and thus they require listening to the android display
- * events.
- */
-public final class DisplayRotationHelper implements DisplayListener {
-  private boolean viewportChanged;
-  private int viewportWidth;
-  private int viewportHeight;
-  private final Display display;
-  private final DisplayManager displayManager;
-  private final CameraManager cameraManager;
-
-  /**
-   * Constructs the DisplayRotationHelper but does not register the listener yet.
-   *
-   * @param context the Android {@link Context}.
-   */
-  public DisplayRotationHelper(Context context) {
-    displayManager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
-    cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
-    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
-    display = windowManager.getDefaultDisplay();
-  }
-
-  /** Registers the display listener. Should be called from {@link Activity#onResume()}. */
-  public void onResume() {
-    displayManager.registerDisplayListener(this, null);
-  }
-
-  /** Unregisters the display listener. Should be called from {@link Activity#onPause()}. */
-  public void onPause() {
-    displayManager.unregisterDisplayListener(this);
-  }
-
-  /**
-   * Records a change in surface dimensions. This will be later used by {@link
-   * #updateSessionIfNeeded(Session)}. Should be called from {@link
-   * android.opengl.GLSurfaceView.Renderer
-   * #onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)}.
-   *
-   * @param width the updated width of the surface.
-   * @param height the updated height of the surface.
-   */
-  public void onSurfaceChanged(int width, int height) {
-    viewportWidth = width;
-    viewportHeight = height;
-    viewportChanged = true;
-  }
-
-  /**
-   * Updates the session display geometry if a change was posted either by {@link
-   * #onSurfaceChanged(int, int)} call or by {@link #onDisplayChanged(int)} system callback. This
-   * function should be called explicitly before each call to {@link Session#update()}. This
-   * function will also clear the 'pending update' (viewportChanged) flag.
-   *
-   * @param session the {@link Session} object to update if display geometry changed.
-   */
-  public void updateSessionIfNeeded(Session session) {
-    if (viewportChanged) {
-      int displayRotation = display.getRotation();
-      session.setDisplayGeometry(displayRotation, viewportWidth, viewportHeight);
-      viewportChanged = false;
-    }
-  }
-
-  /**
-   *  Returns the aspect ratio of the GL surface viewport while accounting for the display rotation
-   *  relative to the device camera sensor orientation.
-   */
-  public float getCameraSensorRelativeViewportAspectRatio(String cameraId) {
-    float aspectRatio;
-    int cameraSensorToDisplayRotation = getCameraSensorToDisplayRotation(cameraId);
-    switch (cameraSensorToDisplayRotation) {
-      case 90:
-      case 270:
-        aspectRatio = (float) viewportHeight / (float) viewportWidth;
-        break;
-      case 0:
-      case 180:
-        aspectRatio = (float) viewportWidth / (float) viewportHeight;
-        break;
-      default:
-        throw new RuntimeException("Unhandled rotation: " + cameraSensorToDisplayRotation);
-    }
-    return aspectRatio;
-  }
-
-  /**
-   * Returns the rotation of the back-facing camera with respect to the display. The value is one of
-   * 0, 90, 180, 270.
-   */
-  public int getCameraSensorToDisplayRotation(String cameraId) {
-    CameraCharacteristics characteristics;
-    try {
-      characteristics = cameraManager.getCameraCharacteristics(cameraId);
-    } catch (CameraAccessException e) {
-      throw new RuntimeException("Unable to determine display orientation", e);
-    }
-
-    // Camera sensor orientation.
-    int sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
-
-    // Current display orientation.
-    int displayOrientation = toDegrees(display.getRotation());
-
-    // Make sure we return 0, 90, 180, or 270 degrees.
-    return (sensorOrientation - displayOrientation + 360) % 360;
-  }
-
-  private int toDegrees(int rotation) {
-    switch (rotation) {
-      case Surface.ROTATION_0:
-        return 0;
-      case Surface.ROTATION_90:
-        return 90;
-      case Surface.ROTATION_180:
-        return 180;
-      case Surface.ROTATION_270:
-        return 270;
-      default:
-        throw new RuntimeException("Unknown rotation " + rotation);
-    }
-  }
-
-  @Override
-  public void onDisplayAdded(int displayId) {}
-
-  @Override
-  public void onDisplayRemoved(int displayId) {}
-
-  @Override
-  public void onDisplayChanged(int displayId) {
-    viewportChanged = true;
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/FullScreenHelper.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/FullScreenHelper.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/FullScreenHelper.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/FullScreenHelper.java	
+++ /dev/null	
@@ -1,46 +0,0 @@
-/*
- * Copyright 2017 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.app.Activity;
-import android.view.View;
-
-/** Helper to set up the Android full screen mode. */
-public final class FullScreenHelper {
-  /**
-   * Sets the Android fullscreen flags. Expected to be called from {@link
-   * Activity#onWindowFocusChanged(boolean hasFocus)}.
-   *
-   * @param activity the Activity on which the full screen mode will be set.
-   * @param hasFocus the hasFocus flag passed from the {@link Activity#onWindowFocusChanged(boolean
-   *     hasFocus)} callback.
-   */
-  public static void setFullScreenOnWindowFocusChanged(Activity activity, boolean hasFocus) {
-    if (hasFocus) {
-      // https://developer.android.com/training/system-ui/immersive.html#sticky
-      activity
-          .getWindow()
-          .getDecorView()
-          .setSystemUiVisibility(
-              View.SYSTEM_UI_FLAG_LAYOUT_STABLE
-                  | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-                  | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                  | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                  | View.SYSTEM_UI_FLAG_FULLSCREEN
-                  | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
-    }
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/SampleRender.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/SampleRender.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/SampleRender.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/SampleRender.java	
+++ /dev/null	
@@ -1,151 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.content.res.AssetManager;
-import android.opengl.GLES30;
-import android.opengl.GLSurfaceView;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-
-/** A SampleRender context. */
-public class SampleRender {
-  private static final String TAG = SampleRender.class.getSimpleName();
-
-  private final AssetManager assetManager;
-
-  private int viewportWidth = 1;
-  private int viewportHeight = 1;
-
-  /**
-   * Constructs a SampleRender object and instantiates GLSurfaceView parameters.
-   *
-   * @param glSurfaceView Android GLSurfaceView
-   * @param renderer Renderer implementation to receive callbacks
-   * @param assetManager AssetManager for loading Android resources
-   */
-  public SampleRender(GLSurfaceView glSurfaceView, Renderer renderer, AssetManager assetManager) {
-    this.assetManager = assetManager;
-    glSurfaceView.setPreserveEGLContextOnPause(true);
-    glSurfaceView.setEGLContextClientVersion(3);
-    glSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
-    glSurfaceView.setRenderer(
-        new GLSurfaceView.Renderer() {
-          @Override
-          public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            GLES30.glEnable(GLES30.GL_BLEND);
-            GLError.maybeThrowGLException("Failed to enable blending", "glEnable");
-            renderer.onSurfaceCreated(SampleRender.this);
-          }
-
-          @Override
-          public void onSurfaceChanged(GL10 gl, int w, int h) {
-            viewportWidth = w;
-            viewportHeight = h;
-            renderer.onSurfaceChanged(SampleRender.this, w, h);
-          }
-
-          @Override
-          public void onDrawFrame(GL10 gl) {
-            clear(/*framebuffer=*/ null, 0f, 0f, 0f, 1f);
-            renderer.onDrawFrame(SampleRender.this);
-          }
-        });
-    glSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
-    glSurfaceView.setWillNotDraw(false);
-  }
-
-  /** Draw a {@link Mesh} with the specified {@link Shader}. */
-  public void draw(Mesh mesh, Shader shader) {
-    draw(mesh, shader, /*framebuffer=*/ null);
-  }
-
-  /**
-   * Draw a {@link Mesh} with the specified {@link Shader} to the given {@link Framebuffer}.
-   *
-   * <p>The {@code framebuffer} argument may be null, in which case the default framebuffer is used.
-   */
-  public void draw(Mesh mesh, Shader shader, Framebuffer framebuffer) {
-    useFramebuffer(framebuffer);
-    shader.lowLevelUse();
-    mesh.lowLevelDraw();
-  }
-
-  /**
-   * Clear the given framebuffer.
-   *
-   * <p>The {@code framebuffer} argument may be null, in which case the default framebuffer is
-   * cleared.
-   */
-  public void clear(Framebuffer framebuffer, float r, float g, float b, float a) {
-    useFramebuffer(framebuffer);
-    GLES30.glClearColor(r, g, b, a);
-    GLError.maybeThrowGLException("Failed to set clear color", "glClearColor");
-    GLES30.glDepthMask(true);
-    GLError.maybeThrowGLException("Failed to set depth write mask", "glDepthMask");
-    GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT | GLES30.GL_DEPTH_BUFFER_BIT);
-    GLError.maybeThrowGLException("Failed to clear framebuffer", "glClear");
-  }
-
-  /** Interface to be implemented for rendering callbacks. */
-  public static interface Renderer {
-    /**
-     * Called by {@link SampleRender} when the GL render surface is created.
-     *
-     * <p>See {@link GLSurfaceView.Renderer#onSurfaceCreated}.
-     */
-    public void onSurfaceCreated(SampleRender render);
-
-    /**
-     * Called by {@link SampleRender} when the GL render surface dimensions are changed.
-     *
-     * <p>See {@link GLSurfaceView.Renderer#onSurfaceChanged}.
-     */
-    public void onSurfaceChanged(SampleRender render, int width, int height);
-
-    /**
-     * Called by {@link SampleRender} when a GL frame is to be rendered.
-     *
-     * <p>See {@link GLSurfaceView.Renderer#onDrawFrame}.
-     */
-    public void onDrawFrame(SampleRender render);
-  }
-
-  /* package-private */
-  AssetManager getAssets() {
-    return assetManager;
-  }
-
-  private void useFramebuffer(Framebuffer framebuffer) {
-    int framebufferId;
-    int viewportWidth;
-    int viewportHeight;
-    if (framebuffer == null) {
-      framebufferId = 0;
-      viewportWidth = this.viewportWidth;
-      viewportHeight = this.viewportHeight;
-    } else {
-      framebufferId = framebuffer.getFramebufferId();
-      viewportWidth = framebuffer.getWidth();
-      viewportHeight = framebuffer.getHeight();
-    }
-    GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, framebufferId);
-    GLError.maybeThrowGLException("Failed to bind framebuffer", "glBindFramebuffer");
-    GLES30.glViewport(0, 0, viewportWidth, viewportHeight);
-    GLError.maybeThrowGLException("Failed to set viewport dimensions", "glViewport");
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/TapHelper.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/TapHelper.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/TapHelper.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/TapHelper.java	
+++ /dev/null	
@@ -1,72 +0,0 @@
-/*
- * Copyright 2017 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.content.Context;
-import android.view.GestureDetector;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.View.OnTouchListener;
-
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.BlockingQueue;
-
-/**
- * Helper to detect taps using Android GestureDetector, and pass the taps between UI thread and
- * render thread.
- */
-public final class TapHelper implements OnTouchListener {
-  private final GestureDetector gestureDetector;
-  private final BlockingQueue<MotionEvent> queuedSingleTaps = new ArrayBlockingQueue<>(16);
-
-  /**
-   * Creates the tap helper.
-   *
-   * @param context the application's context.
-   */
-  public TapHelper(Context context) {
-    gestureDetector =
-        new GestureDetector(
-            context,
-            new GestureDetector.SimpleOnGestureListener() {
-              @Override
-              public boolean onSingleTapUp(MotionEvent e) {
-                // Queue tap if there is space. Tap is lost if queue is full.
-                queuedSingleTaps.offer(e);
-                return true;
-              }
-
-              @Override
-              public boolean onDown(MotionEvent e) {
-                return true;
-              }
-            });
-  }
-
-  /**
-   * Polls for a tap.
-   *
-   * @return if a tap was queued, a MotionEvent for the tap. Otherwise null if no taps are queued.
-   */
-  public MotionEvent poll() {
-    return queuedSingleTaps.poll();
-  }
-
-  @Override
-  public boolean onTouch(View view, MotionEvent motionEvent) {
-    return gestureDetector.onTouchEvent(motionEvent);
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/Texture.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Texture.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Texture.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Texture.java	
+++ /dev/null	
@@ -1,201 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.opengl.GLES11Ext;
-import android.opengl.GLES30;
-import android.util.Log;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-/** A GPU-side texture. */
-public class Texture implements Closeable {
-  private static final String TAG = Texture.class.getSimpleName();
-
-  private final int[] textureId = {0};
-  private final Target target;
-
-  /**
-   * Describes the way the texture's edges are rendered.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexParameter.xhtml">GL_TEXTURE_WRAP_S</a>.
-   */
-  public enum WrapMode {
-    CLAMP_TO_EDGE(GLES30.GL_CLAMP_TO_EDGE),
-    MIRRORED_REPEAT(GLES30.GL_MIRRORED_REPEAT),
-    REPEAT(GLES30.GL_REPEAT);
-
-    /* package-private */
-    final int glesEnum;
-
-    private WrapMode(int glesEnum) {
-      this.glesEnum = glesEnum;
-    }
-  }
-
-  /**
-   * Describes the target this texture is bound to.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glBindTexture.xhtml">glBindTexture</a>.
-   */
-  public enum Target {
-    TEXTURE_2D(GLES30.GL_TEXTURE_2D),
-    TEXTURE_EXTERNAL_OES(GLES11Ext.GL_TEXTURE_EXTERNAL_OES),
-    TEXTURE_CUBE_MAP(GLES30.GL_TEXTURE_CUBE_MAP);
-
-    final int glesEnum;
-
-    private Target(int glesEnum) {
-      this.glesEnum = glesEnum;
-    }
-  }
-
-  /**
-   * Describes the color format of the texture.
-   *
-   * @see <a
-   *     href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml">glTexImage2d</a>.
-   */
-  public enum ColorFormat {
-    LINEAR(GLES30.GL_RGBA8),
-    SRGB(GLES30.GL_SRGB8_ALPHA8);
-
-    final int glesEnum;
-
-    private ColorFormat(int glesEnum) {
-      this.glesEnum = glesEnum;
-    }
-  }
-
-  /**
-   * Construct an empty {@link Texture}.
-   *
-   * <p>Since {@link Texture}s created in this way are not populated with data, this method is
-   * mostly only useful for creating {@link Target.TEXTURE_EXTERNAL_OES} textures. See {@link
-   * #createFromAsset} if you want a texture with data.
-   */
-  public Texture(SampleRender render, Target target, WrapMode wrapMode) {
-    this(render, target, wrapMode, /*useMipmaps=*/ true);
-  }
-
-  public Texture(SampleRender render, Target target, WrapMode wrapMode, boolean useMipmaps) {
-    this.target = target;
-
-    GLES30.glGenTextures(1, textureId, 0);
-    GLError.maybeThrowGLException("Texture creation failed", "glGenTextures");
-
-    int minFilter = useMipmaps ? GLES30.GL_LINEAR_MIPMAP_LINEAR : GLES30.GL_LINEAR;
-
-    try {
-      GLES30.glBindTexture(target.glesEnum, textureId[0]);
-      GLError.maybeThrowGLException("Failed to bind texture", "glBindTexture");
-      GLES30.glTexParameteri(target.glesEnum, GLES30.GL_TEXTURE_MIN_FILTER, minFilter);
-      GLError.maybeThrowGLException("Failed to set texture parameter", "glTexParameteri");
-      GLES30.glTexParameteri(target.glesEnum, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);
-      GLError.maybeThrowGLException("Failed to set texture parameter", "glTexParameteri");
-
-      GLES30.glTexParameteri(target.glesEnum, GLES30.GL_TEXTURE_WRAP_S, wrapMode.glesEnum);
-      GLError.maybeThrowGLException("Failed to set texture parameter", "glTexParameteri");
-      GLES30.glTexParameteri(target.glesEnum, GLES30.GL_TEXTURE_WRAP_T, wrapMode.glesEnum);
-      GLError.maybeThrowGLException("Failed to set texture parameter", "glTexParameteri");
-    } catch (Throwable t) {
-      close();
-      throw t;
-    }
-  }
-
-  /** Create a texture from the given asset file name. */
-  public static Texture createFromAsset(
-      SampleRender render, String assetFileName, WrapMode wrapMode, ColorFormat colorFormat)
-      throws IOException {
-    Texture texture = new Texture(render, Target.TEXTURE_2D, wrapMode);
-    Bitmap bitmap = null;
-    try {
-      // The following lines up to glTexImage2D could technically be replaced with
-      // GLUtils.texImage2d, but this method does not allow for loading sRGB images.
-
-      // Load and convert the bitmap and copy its contents to a direct ByteBuffer. Despite its name,
-      // the ARGB_8888 config is actually stored in RGBA order.
-      bitmap =
-          convertBitmapToConfig(
-              BitmapFactory.decodeStream(render.getAssets().open(assetFileName)),
-              Bitmap.Config.ARGB_8888);
-      ByteBuffer buffer = ByteBuffer.allocateDirect(bitmap.getByteCount());
-      bitmap.copyPixelsToBuffer(buffer);
-      buffer.rewind();
-
-      GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, texture.getTextureId());
-      GLError.maybeThrowGLException("Failed to bind texture", "glBindTexture");
-      GLES30.glTexImage2D(
-          GLES30.GL_TEXTURE_2D,
-          /*level=*/ 0,
-          colorFormat.glesEnum,
-          bitmap.getWidth(),
-          bitmap.getHeight(),
-          /*border=*/ 0,
-          GLES30.GL_RGBA,
-          GLES30.GL_UNSIGNED_BYTE,
-          buffer);
-      GLError.maybeThrowGLException("Failed to populate texture data", "glTexImage2D");
-      GLES30.glGenerateMipmap(GLES30.GL_TEXTURE_2D);
-      GLError.maybeThrowGLException("Failed to generate mipmaps", "glGenerateMipmap");
-    } catch (Throwable t) {
-      texture.close();
-      throw t;
-    } finally {
-      if (bitmap != null) {
-        bitmap.recycle();
-      }
-    }
-    return texture;
-  }
-
-  @Override
-  public void close() {
-    if (textureId[0] != 0) {
-      GLES30.glDeleteTextures(1, textureId, 0);
-      GLError.maybeLogGLError(Log.WARN, TAG, "Failed to free texture", "glDeleteTextures");
-      textureId[0] = 0;
-    }
-  }
-
-  /** Retrieve the native texture ID. */
-  public int getTextureId() {
-    return textureId[0];
-  }
-
-  /* package-private */
-  Target getTarget() {
-    return target;
-  }
-
-  private static Bitmap convertBitmapToConfig(Bitmap bitmap, Bitmap.Config config) {
-    // We use this method instead of BitmapFactory.Options.outConfig to support a minimum of Android
-    // API level 24.
-    if (bitmap.getConfig() == config) {
-      return bitmap;
-    }
-    Bitmap result = bitmap.copy(config, /*isMutable=*/ false);
-    bitmap.recycle();
-    return result;
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/TrackingStateHelper.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/TrackingStateHelper.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/TrackingStateHelper.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/TrackingStateHelper.java	
+++ /dev/null	
@@ -1,91 +0,0 @@
-/*
- * Copyright 2019 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.app.Activity;
-import android.view.WindowManager;
-
-import com.google.ar.core.Camera;
-import com.google.ar.core.TrackingFailureReason;
-import com.google.ar.core.TrackingState;
-
-/** Gets human readibly tracking failure reasons and suggested actions. */
-public final class TrackingStateHelper {
-  private static final String INSUFFICIENT_FEATURES_MESSAGE =
-      "Can't find anything. Aim device at a surface with more texture or color.";
-  private static final String EXCESSIVE_MOTION_MESSAGE = "Moving too fast. Slow down.";
-  private static final String INSUFFICIENT_LIGHT_MESSAGE =
-      "Too dark. Try moving to a well-lit area.";
-  private static final String INSUFFICIENT_LIGHT_ANDROID_S_MESSAGE =
-      "Too dark. Try moving to a well-lit area."
-      + " Also, make sure the Block Camera is set to off in system settings.";
-  private static final String BAD_STATE_MESSAGE =
-      "Tracking lost due to bad internal state. Please try restarting the AR experience.";
-  private static final String CAMERA_UNAVAILABLE_MESSAGE =
-      "Another app is using the camera. Tap on this app or try closing the other one.";
-  private static final int ANDROID_S_SDK_VERSION = 31;
-
-  private final Activity activity;
-
-  private TrackingState previousTrackingState;
-
-  public TrackingStateHelper(Activity activity) {
-    this.activity = activity;
-  }
-
-  /** Keep the screen unlocked while tracking, but allow it to lock when tracking stops. */
-  public void updateKeepScreenOnFlag(TrackingState trackingState) {
-    if (trackingState == previousTrackingState) {
-      return;
-    }
-
-    previousTrackingState = trackingState;
-    switch (trackingState) {
-      case PAUSED:
-      case STOPPED:
-        activity.runOnUiThread(
-            () -> activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON));
-        break;
-      case TRACKING:
-        activity.runOnUiThread(
-            () -> activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON));
-        break;
-    }
-  }
-
-  public static String getTrackingFailureReasonString(Camera camera) {
-    TrackingFailureReason reason = camera.getTrackingFailureReason();
-    switch (reason) {
-      case NONE:
-        return "";
-      case BAD_STATE:
-        return BAD_STATE_MESSAGE;
-      case INSUFFICIENT_LIGHT:
-        if (android.os.Build.VERSION.SDK_INT < ANDROID_S_SDK_VERSION) {
-            return INSUFFICIENT_LIGHT_MESSAGE;
-        } else {
-            return INSUFFICIENT_LIGHT_ANDROID_S_MESSAGE;
-        }
-      case EXCESSIVE_MOTION:
-        return EXCESSIVE_MOTION_MESSAGE;
-      case INSUFFICIENT_FEATURES:
-        return INSUFFICIENT_FEATURES_MESSAGE;
-      case CAMERA_UNAVAILABLE:
-        return CAMERA_UNAVAILABLE_MESSAGE;
-    }
-    return "Unknown tracking failure reason: " + reason;
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/PlaneRenderer.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/PlaneRenderer.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/PlaneRenderer.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/arcore/PlaneRenderer.java	
+++ /dev/null	
@@ -1,326 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender.arcore;
-
-import android.opengl.Matrix;
-
-import com.example.memotion.arcamera.common.samplerender.IndexBuffer;
-import com.example.memotion.arcamera.common.samplerender.Mesh;
-import com.example.memotion.arcamera.common.samplerender.SampleRender;
-import com.example.memotion.arcamera.common.samplerender.Shader;
-import com.example.memotion.arcamera.common.samplerender.Shader.BlendFactor;
-import com.example.memotion.arcamera.common.samplerender.Texture;
-import com.example.memotion.arcamera.common.samplerender.VertexBuffer;
-import com.google.ar.core.Camera;
-import com.google.ar.core.Plane;
-import com.google.ar.core.Pose;
-import com.google.ar.core.TrackingState;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/** Renders the detected AR planes. */
-public class PlaneRenderer {
-  private static final String TAG = PlaneRenderer.class.getSimpleName();
-
-  // Shader names.
-  private static final String VERTEX_SHADER_NAME = "shaders/plane.vert";
-  private static final String FRAGMENT_SHADER_NAME = "shaders/plane.frag";
-  private static final String TEXTURE_NAME = "models/trigrid.png";
-
-  private static final int BYTES_PER_FLOAT = Float.SIZE / 8;
-  private static final int BYTES_PER_INT = Integer.SIZE / 8;
-  private static final int COORDS_PER_VERTEX = 3; // x, z, alpha
-
-  private static final int VERTS_PER_BOUNDARY_VERT = 2;
-  private static final int INDICES_PER_BOUNDARY_VERT = 3;
-  private static final int INITIAL_BUFFER_BOUNDARY_VERTS = 64;
-
-  private static final int INITIAL_VERTEX_BUFFER_SIZE_BYTES =
-      BYTES_PER_FLOAT * COORDS_PER_VERTEX * VERTS_PER_BOUNDARY_VERT * INITIAL_BUFFER_BOUNDARY_VERTS;
-
-  private static final int INITIAL_INDEX_BUFFER_SIZE_BYTES =
-      BYTES_PER_INT
-          * INDICES_PER_BOUNDARY_VERT
-          * INDICES_PER_BOUNDARY_VERT
-          * INITIAL_BUFFER_BOUNDARY_VERTS;
-
-  private static final float FADE_RADIUS_M = 0.25f;
-  private static final float DOTS_PER_METER = 10.0f;
-  private static final float EQUILATERAL_TRIANGLE_SCALE = (float) (1 / Math.sqrt(3));
-
-  // Using the "signed distance field" approach to render sharp lines and circles.
-  // {dotThreshold, lineThreshold, lineFadeSpeed, occlusionScale}
-  // dotThreshold/lineThreshold: red/green intensity above which dots/lines are present
-  // lineFadeShrink:  lines will fade in between alpha = 1-(1/lineFadeShrink) and 1.0
-  // occlusionShrink: occluded planes will fade out between alpha = 0 and 1/occlusionShrink
-  private static final float[] GRID_CONTROL = {0.2f, 0.4f, 2.0f, 1.5f};
-
-  private final Mesh mesh;
-  private final IndexBuffer indexBufferObject;
-  private final VertexBuffer vertexBufferObject;
-  private final Shader shader;
-
-  private FloatBuffer vertexBuffer =
-      ByteBuffer.allocateDirect(INITIAL_VERTEX_BUFFER_SIZE_BYTES)
-          .order(ByteOrder.nativeOrder())
-          .asFloatBuffer();
-  private IntBuffer indexBuffer =
-      ByteBuffer.allocateDirect(INITIAL_INDEX_BUFFER_SIZE_BYTES)
-          .order(ByteOrder.nativeOrder())
-          .asIntBuffer();
-
-  // Temporary lists/matrices allocated here to reduce number of allocations for each frame.
-  private final float[] viewMatrix = new float[16];
-  private final float[] modelMatrix = new float[16];
-  private final float[] modelViewMatrix = new float[16];
-  private final float[] modelViewProjectionMatrix = new float[16];
-  private final float[] planeAngleUvMatrix =
-      new float[4]; // 2x2 rotation matrix applied to uv coords.
-  private final float[] normalVector = new float[3];
-
-  private final Map<Plane, Integer> planeIndexMap = new HashMap<>();
-
-  /**
-   * Allocates and initializes OpenGL resources needed by the plane renderer. Must be called during
-   * a {@link SampleRender.Renderer} callback, typically in {@link
-   * SampleRender.Renderer#onSurfaceCreated}.
-   */
-  public PlaneRenderer(SampleRender render) throws IOException {
-    Texture texture =
-        Texture.createFromAsset(
-            render, TEXTURE_NAME, Texture.WrapMode.REPEAT, Texture.ColorFormat.LINEAR);
-    shader =
-        Shader.createFromAssets(render, VERTEX_SHADER_NAME, FRAGMENT_SHADER_NAME, /*defines=*/ null)
-            .setTexture("u_Texture", texture)
-            .setVec4("u_GridControl", GRID_CONTROL)
-            .setBlend(
-                BlendFactor.DST_ALPHA, // RGB (src)
-                BlendFactor.ONE, // RGB (dest)
-                BlendFactor.ZERO, // ALPHA (src)
-                BlendFactor.ONE_MINUS_SRC_ALPHA) // ALPHA (dest)
-            .setDepthWrite(false);
-
-    indexBufferObject = new IndexBuffer(render, /*entries=*/ null);
-    vertexBufferObject = new VertexBuffer(render, COORDS_PER_VERTEX, /*entries=*/ null);
-    VertexBuffer[] vertexBuffers = {vertexBufferObject};
-    mesh = new Mesh(render, Mesh.PrimitiveMode.TRIANGLE_STRIP, indexBufferObject, vertexBuffers);
-  }
-
-  /** Updates the plane model transform matrix and extents. */
-  private void updatePlaneParameters(
-      float[] planeMatrix, float extentX, float extentZ, FloatBuffer boundary) {
-    System.arraycopy(planeMatrix, 0, modelMatrix, 0, 16);
-    if (boundary == null) {
-      vertexBuffer.limit(0);
-      indexBuffer.limit(0);
-      return;
-    }
-
-    // Generate a new set of vertices and a corresponding triangle strip index set so that
-    // the plane boundary polygon has a fading edge. This is done by making a copy of the
-    // boundary polygon vertices and scaling it down around center to push it inwards. Then
-    // the index buffer is setup accordingly.
-    boundary.rewind();
-    int boundaryVertices = boundary.limit() / 2;
-    int numVertices;
-    int numIndices;
-
-    numVertices = boundaryVertices * VERTS_PER_BOUNDARY_VERT;
-    // drawn as GL_TRIANGLE_STRIP with 3n-2 triangles (n-2 for fill, 2n for perimeter).
-    numIndices = boundaryVertices * INDICES_PER_BOUNDARY_VERT;
-
-    if (vertexBuffer.capacity() < numVertices * COORDS_PER_VERTEX) {
-      int size = vertexBuffer.capacity();
-      while (size < numVertices * COORDS_PER_VERTEX) {
-        size *= 2;
-      }
-      vertexBuffer =
-          ByteBuffer.allocateDirect(BYTES_PER_FLOAT * size)
-              .order(ByteOrder.nativeOrder())
-              .asFloatBuffer();
-    }
-    vertexBuffer.rewind();
-    vertexBuffer.limit(numVertices * COORDS_PER_VERTEX);
-
-    if (indexBuffer.capacity() < numIndices) {
-      int size = indexBuffer.capacity();
-      while (size < numIndices) {
-        size *= 2;
-      }
-      indexBuffer =
-          ByteBuffer.allocateDirect(BYTES_PER_INT * size)
-              .order(ByteOrder.nativeOrder())
-              .asIntBuffer();
-    }
-    indexBuffer.rewind();
-    indexBuffer.limit(numIndices);
-
-    // Note: when either dimension of the bounding box is smaller than 2*FADE_RADIUS_M we
-    // generate a bunch of 0-area triangles.  These don't get rendered though so it works
-    // out ok.
-    float xScale = Math.max((extentX - 2 * FADE_RADIUS_M) / extentX, 0.0f);
-    float zScale = Math.max((extentZ - 2 * FADE_RADIUS_M) / extentZ, 0.0f);
-
-    while (boundary.hasRemaining()) {
-      float x = boundary.get();
-      float z = boundary.get();
-      vertexBuffer.put(x);
-      vertexBuffer.put(z);
-      vertexBuffer.put(0.0f);
-      vertexBuffer.put(x * xScale);
-      vertexBuffer.put(z * zScale);
-      vertexBuffer.put(1.0f);
-    }
-
-    // step 1, perimeter
-    indexBuffer.put((short) ((boundaryVertices - 1) * 2));
-    for (int i = 0; i < boundaryVertices; ++i) {
-      indexBuffer.put((short) (i * 2));
-      indexBuffer.put((short) (i * 2 + 1));
-    }
-    indexBuffer.put((short) 1);
-    // This leaves us on the interior edge of the perimeter between the inset vertices
-    // for boundary verts n-1 and 0.
-
-    // step 2, interior:
-    for (int i = 1; i < boundaryVertices / 2; ++i) {
-      indexBuffer.put((short) ((boundaryVertices - 1 - i) * 2 + 1));
-      indexBuffer.put((short) (i * 2 + 1));
-    }
-    if (boundaryVertices % 2 != 0) {
-      indexBuffer.put((short) ((boundaryVertices / 2) * 2 + 1));
-    }
-  }
-
-  /**
-   * Draws the collection of tracked planes, with closer planes hiding more distant ones.
-   *
-   * @param allPlanes The collection of planes to draw.
-   * @param cameraPose The pose of the camera, as returned by {@link Camera#getPose()}
-   * @param cameraProjection The projection matrix, as returned by {@link
-   *     Camera#getProjectionMatrix(float[], int, float, float)}
-   */
-  public void drawPlanes(
-      SampleRender render, Collection<Plane> allPlanes, Pose cameraPose, float[] cameraProjection) {
-    // Planes must be sorted by distance from camera so that we draw closer planes first, and
-    // they occlude the farther planes.
-    List<SortablePlane> sortedPlanes = new ArrayList<>();
-
-    for (Plane plane : allPlanes) {
-      if (plane.getTrackingState() != TrackingState.TRACKING || plane.getSubsumedBy() != null) {
-        continue;
-      }
-
-      float distance = calculateDistanceToPlane(plane.getCenterPose(), cameraPose);
-      if (distance < 0) { // Plane is back-facing.
-        continue;
-      }
-      sortedPlanes.add(new SortablePlane(distance, plane));
-    }
-    Collections.sort(
-        sortedPlanes,
-        new Comparator<SortablePlane>() {
-          @Override
-          public int compare(SortablePlane a, SortablePlane b) {
-            return Float.compare(b.distance, a.distance);
-          }
-        });
-
-    cameraPose.inverse().toMatrix(viewMatrix, 0);
-
-    for (SortablePlane sortedPlane : sortedPlanes) {
-      Plane plane = sortedPlane.plane;
-      float[] planeMatrix = new float[16];
-      plane.getCenterPose().toMatrix(planeMatrix, 0);
-
-      // Get transformed Y axis of plane's coordinate system.
-      plane.getCenterPose().getTransformedAxis(1, 1.0f, normalVector, 0);
-
-      updatePlaneParameters(
-          planeMatrix, plane.getExtentX(), plane.getExtentZ(), plane.getPolygon());
-
-      // Get plane index. Keep a map to assign same indices to same planes.
-      Integer planeIndex = planeIndexMap.get(plane);
-      if (planeIndex == null) {
-        planeIndex = planeIndexMap.size();
-        planeIndexMap.put(plane, planeIndex);
-      }
-
-      // Each plane will have its own angle offset from others, to make them easier to
-      // distinguish. Compute a 2x2 rotation matrix from the angle.
-      float angleRadians = planeIndex * 0.144f;
-      float uScale = DOTS_PER_METER;
-      float vScale = DOTS_PER_METER * EQUILATERAL_TRIANGLE_SCALE;
-      planeAngleUvMatrix[0] = +(float) Math.cos(angleRadians) * uScale;
-      planeAngleUvMatrix[1] = -(float) Math.sin(angleRadians) * vScale;
-      planeAngleUvMatrix[2] = +(float) Math.sin(angleRadians) * uScale;
-      planeAngleUvMatrix[3] = +(float) Math.cos(angleRadians) * vScale;
-
-      // Build the ModelView and ModelViewProjection matrices
-      // for calculating cube position and light.
-      Matrix.multiplyMM(modelViewMatrix, 0, viewMatrix, 0, modelMatrix, 0);
-      Matrix.multiplyMM(modelViewProjectionMatrix, 0, cameraProjection, 0, modelViewMatrix, 0);
-
-      // Populate the shader uniforms for this frame.
-      shader.setMat4("u_Model", modelMatrix);
-      shader.setMat4("u_ModelViewProjection", modelViewProjectionMatrix);
-      shader.setMat2("u_PlaneUvMatrix", planeAngleUvMatrix);
-      shader.setVec3("u_Normal", normalVector);
-
-      // Set the position of the plane
-      vertexBufferObject.set(vertexBuffer);
-      indexBufferObject.set(indexBuffer);
-
-      render.draw(mesh, shader);
-    }
-  }
-
-  private static class SortablePlane {
-    final float distance;
-    final Plane plane;
-
-    SortablePlane(float distance, Plane plane) {
-      this.distance = distance;
-      this.plane = plane;
-    }
-  }
-
-  // Calculate the normal distance to plane from cameraPose, the given planePose should have y axis
-  // parallel to plane's normal, for example plane's center pose or hit test pose.
-  public static float calculateDistanceToPlane(Pose planePose, Pose cameraPose) {
-    float[] normal = new float[3];
-    float cameraX = cameraPose.tx();
-    float cameraY = cameraPose.ty();
-    float cameraZ = cameraPose.tz();
-    // Get transformed Y axis of plane's coordinate system.
-    planePose.getTransformedAxis(1, 1.0f, normal, 0);
-    // Compute dot product of plane's normal with vector from camera to plane center.
-    return (cameraX - planePose.tx()) * normal[0]
-        + (cameraY - planePose.ty()) * normal[1]
-        + (cameraZ - planePose.tz()) * normal[2];
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/Framebuffer.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Framebuffer.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Framebuffer.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/Framebuffer.java	
+++ /dev/null	
@@ -1,173 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.opengl.GLES30;
-import android.util.Log;
-
-import java.io.Closeable;
-
-/** A framebuffer associated with a texture. */
-public class Framebuffer implements Closeable {
-  private static final String TAG = Framebuffer.class.getSimpleName();
-
-  private final int[] framebufferId = {0};
-  private final Texture colorTexture;
-  private final Texture depthTexture;
-  private int width = -1;
-  private int height = -1;
-
-  /**
-   * Constructs a {@link Framebuffer} which renders internally to a texture.
-   *
-   * <p>In order to render to the {@link Framebuffer}, use {@link SampleRender#draw(Mesh, Shader,
-   * Framebuffer)}.
-   */
-  public Framebuffer(SampleRender render, int width, int height) {
-    try {
-      colorTexture =
-          new Texture(
-              render,
-              Texture.Target.TEXTURE_2D,
-              Texture.WrapMode.CLAMP_TO_EDGE,
-              /*useMipmaps=*/ false);
-      depthTexture =
-          new Texture(
-              render,
-              Texture.Target.TEXTURE_2D,
-              Texture.WrapMode.CLAMP_TO_EDGE,
-              /*useMipmaps=*/ false);
-
-      // Set parameters of the depth texture so that it's readable by shaders.
-      GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, depthTexture.getTextureId());
-      GLError.maybeThrowGLException("Failed to bind depth texture", "glBindTexture");
-      GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_COMPARE_MODE, GLES30.GL_NONE);
-      GLError.maybeThrowGLException("Failed to set texture parameter", "glTexParameteri");
-      GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);
-      GLError.maybeThrowGLException("Failed to set texture parameter", "glTexParameteri");
-      GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_NEAREST);
-      GLError.maybeThrowGLException("Failed to set texture parameter", "glTexParameteri");
-
-      // Set initial dimensions.
-      resize(width, height);
-
-      // Create framebuffer object and bind to the color and depth textures.
-      GLES30.glGenFramebuffers(1, framebufferId, 0);
-      GLError.maybeThrowGLException("Framebuffer creation failed", "glGenFramebuffers");
-      GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, framebufferId[0]);
-      GLError.maybeThrowGLException("Failed to bind framebuffer", "glBindFramebuffer");
-      GLES30.glFramebufferTexture2D(
-          GLES30.GL_FRAMEBUFFER,
-          GLES30.GL_COLOR_ATTACHMENT0,
-          GLES30.GL_TEXTURE_2D,
-          colorTexture.getTextureId(),
-          /*level=*/ 0);
-      GLError.maybeThrowGLException(
-          "Failed to bind color texture to framebuffer", "glFramebufferTexture2D");
-      GLES30.glFramebufferTexture2D(
-          GLES30.GL_FRAMEBUFFER,
-          GLES30.GL_DEPTH_ATTACHMENT,
-          GLES30.GL_TEXTURE_2D,
-          depthTexture.getTextureId(),
-          /*level=*/ 0);
-      GLError.maybeThrowGLException(
-          "Failed to bind depth texture to framebuffer", "glFramebufferTexture2D");
-
-      int status = GLES30.glCheckFramebufferStatus(GLES30.GL_FRAMEBUFFER);
-      if (status != GLES30.GL_FRAMEBUFFER_COMPLETE) {
-        throw new IllegalStateException("Framebuffer construction not complete: code " + status);
-      }
-    } catch (Throwable t) {
-      close();
-      throw t;
-    }
-  }
-
-  @Override
-  public void close() {
-    if (framebufferId[0] != 0) {
-      GLES30.glDeleteFramebuffers(1, framebufferId, 0);
-      GLError.maybeLogGLError(Log.WARN, TAG, "Failed to free framebuffer", "glDeleteFramebuffers");
-      framebufferId[0] = 0;
-    }
-    colorTexture.close();
-    depthTexture.close();
-  }
-
-  /** Resizes the framebuffer to the given dimensions. */
-  public void resize(int width, int height) {
-    if (this.width == width && this.height == height) {
-      return;
-    }
-    this.width = width;
-    this.height = height;
-
-    // Color texture
-    GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, colorTexture.getTextureId());
-    GLError.maybeThrowGLException("Failed to bind color texture", "glBindTexture");
-    GLES30.glTexImage2D(
-        GLES30.GL_TEXTURE_2D,
-        /*level=*/ 0,
-        GLES30.GL_RGBA,
-        width,
-        height,
-        /*border=*/ 0,
-        GLES30.GL_RGBA,
-        GLES30.GL_UNSIGNED_BYTE,
-        /*pixels=*/ null);
-    GLError.maybeThrowGLException("Failed to specify color texture format", "glTexImage2D");
-
-    // Depth texture
-    GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, depthTexture.getTextureId());
-    GLError.maybeThrowGLException("Failed to bind depth texture", "glBindTexture");
-    GLES30.glTexImage2D(
-        GLES30.GL_TEXTURE_2D,
-        /*level=*/ 0,
-        GLES30.GL_DEPTH_COMPONENT32F,
-        width,
-        height,
-        /*border=*/ 0,
-        GLES30.GL_DEPTH_COMPONENT,
-        GLES30.GL_FLOAT,
-        /*pixels=*/ null);
-    GLError.maybeThrowGLException("Failed to specify depth texture format", "glTexImage2D");
-  }
-
-  /** Returns the color texture associated with this framebuffer. */
-  public Texture getColorTexture() {
-    return colorTexture;
-  }
-
-  /** Returns the depth texture associated with this framebuffer. */
-  public Texture getDepthTexture() {
-    return depthTexture;
-  }
-
-  /** Returns the width of the framebuffer. */
-  public int getWidth() {
-    return width;
-  }
-
-  /** Returns the height of the framebuffer. */
-  public int getHeight() {
-    return height;
-  }
-
-  /* package-private */
-  int getFramebufferId() {
-    return framebufferId[0];
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/helpers/DepthSettings.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/helpers/DepthSettings.java b/app/src/main/java/com/example/memotion/arcamera/common/helpers/DepthSettings.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/helpers/DepthSettings.java	
+++ /dev/null	
@@ -1,82 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.helpers;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-
-/** Manages the Occlusion option setting and shared preferences. */
-public class DepthSettings {
-  public static final String SHARED_PREFERENCES_ID = "SHARED_PREFERENCES_OCCLUSION_OPTIONS";
-  public static final String SHARED_PREFERENCES_SHOW_DEPTH_ENABLE_DIALOG_OOBE =
-      "show_depth_enable_dialog_oobe";
-  public static final String SHARED_PREFERENCES_USE_DEPTH_FOR_OCCLUSION = "use_depth_for_occlusion";
-
-  // Current depth-based settings used by the app.
-  private boolean depthColorVisualizationEnabled = false;
-  private boolean useDepthForOcclusion = false;
-  private SharedPreferences sharedPreferences;
-
-  /** Initializes the current settings based on when the app was last used. */
-  public void onCreate(Context context) {
-    sharedPreferences = context.getSharedPreferences(SHARED_PREFERENCES_ID, Context.MODE_PRIVATE);
-    useDepthForOcclusion =
-        sharedPreferences.getBoolean(SHARED_PREFERENCES_USE_DEPTH_FOR_OCCLUSION, false);
-  }
-
-  /** Retrieves whether depth-based occlusion is enabled. */
-  public boolean useDepthForOcclusion() {
-    return useDepthForOcclusion;
-  }
-
-  public void setUseDepthForOcclusion(boolean enable) {
-    if (enable == useDepthForOcclusion) {
-      return; // No change.
-    }
-
-    // Updates the stored default settings.
-    useDepthForOcclusion = enable;
-    SharedPreferences.Editor editor = sharedPreferences.edit();
-    editor.putBoolean(SHARED_PREFERENCES_USE_DEPTH_FOR_OCCLUSION, useDepthForOcclusion);
-    editor.apply();
-  }
-
-  /** Retrieves whether to render the depth map visualization instead of the camera feed. */
-  public boolean depthColorVisualizationEnabled() {
-    return depthColorVisualizationEnabled;
-  }
-
-  public void setDepthColorVisualizationEnabled(boolean depthColorVisualizationEnabled) {
-    this.depthColorVisualizationEnabled = depthColorVisualizationEnabled;
-  }
-
-  /** Determines if the initial prompt to use depth-based occlusion should be shown. */
-  public boolean shouldShowDepthEnableDialog() {
-    // Checks if this dialog has been called before on this device.
-    boolean showDialog =
-        sharedPreferences.getBoolean(SHARED_PREFERENCES_SHOW_DEPTH_ENABLE_DIALOG_OOBE, true);
-
-    if (showDialog) {
-      // Only ever shows the dialog on the first time.  If the user wants to adjust these settings
-      // again, they can use the gear icon to invoke the settings menu dialog.
-      SharedPreferences.Editor editor = sharedPreferences.edit();
-      editor.putBoolean(SHARED_PREFERENCES_SHOW_DEPTH_ENABLE_DIALOG_OOBE, false);
-      editor.apply();
-    }
-
-    return showDialog;
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/GLError.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/GLError.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/GLError.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/GLError.java	
+++ /dev/null	
@@ -1,77 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.opengl.GLES30;
-import android.opengl.GLException;
-import android.opengl.GLU;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/** Module for handling OpenGL errors. */
-public class GLError {
-  /** Throws a {@link GLException} if a GL error occurred. */
-  public static void maybeThrowGLException(String reason, String api) {
-    List<Integer> errorCodes = getGlErrors();
-    if (errorCodes != null) {
-      throw new GLException(errorCodes.get(0), formatErrorMessage(reason, api, errorCodes));
-    }
-  }
-
-  /** Logs a message with the given logcat priority if a GL error occurred. */
-  public static void maybeLogGLError(int priority, String tag, String reason, String api) {
-    List<Integer> errorCodes = getGlErrors();
-    if (errorCodes != null) {
-      Log.println(priority, tag, formatErrorMessage(reason, api, errorCodes));
-    }
-  }
-
-  private static String formatErrorMessage(String reason, String api, List<Integer> errorCodes) {
-    StringBuilder builder = new StringBuilder(String.format("%s: %s: ", reason, api));
-    Iterator<Integer> iterator = errorCodes.iterator();
-    while (iterator.hasNext()) {
-      int errorCode = iterator.next();
-      builder.append(String.format("%s (%d)", GLU.gluErrorString(errorCode), errorCode));
-      if (iterator.hasNext()) {
-        builder.append(", ");
-      }
-    }
-    return builder.toString();
-  }
-
-  private static List<Integer> getGlErrors() {
-    int errorCode = GLES30.glGetError();
-    // Shortcut for no errors
-    if (errorCode == GLES30.GL_NO_ERROR) {
-      return null;
-    }
-    List<Integer> errorCodes = new ArrayList<>();
-    errorCodes.add(errorCode);
-    while (true) {
-      errorCode = GLES30.glGetError();
-      if (errorCode == GLES30.GL_NO_ERROR) {
-        break;
-      }
-      errorCodes.add(errorCode);
-    }
-    return errorCodes;
-  }
-
-  private GLError() {}
-}
Index: app/src/main/java/com/example/memotion/arcamera/common/samplerender/GpuBuffer.java
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/GpuBuffer.java b/app/src/main/java/com/example/memotion/arcamera/common/samplerender/GpuBuffer.java
deleted file mode 100644
--- a/app/src/main/java/com/example/memotion/arcamera/common/samplerender/GpuBuffer.java	
+++ /dev/null	
@@ -1,125 +0,0 @@
-/*
- * Copyright 2020 Google LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.memotion.arcamera.common.samplerender;
-
-import android.opengl.GLES30;
-import android.util.Log;
-
-import java.nio.Buffer;
-
-/* package-private */
-class GpuBuffer {
-  private static final String TAG = GpuBuffer.class.getSimpleName();
-
-  // These values refer to the byte count of the corresponding Java datatypes.
-  public static final int INT_SIZE = 4;
-  public static final int FLOAT_SIZE = 4;
-
-  private final int target;
-  private final int numberOfBytesPerEntry;
-  private final int[] bufferId = {0};
-  private int size;
-  private int capacity;
-
-  public GpuBuffer(int target, int numberOfBytesPerEntry, Buffer entries) {
-    if (entries != null) {
-      if (!entries.isDirect()) {
-        throw new IllegalArgumentException("If non-null, entries buffer must be a direct buffer");
-      }
-      // Some GPU drivers will fail with out of memory errors if glBufferData or glBufferSubData is
-      // called with a size of 0, so avoid this case.
-      if (entries.limit() == 0) {
-        entries = null;
-      }
-    }
-
-    this.target = target;
-    this.numberOfBytesPerEntry = numberOfBytesPerEntry;
-    if (entries == null) {
-      this.size = 0;
-      this.capacity = 0;
-    } else {
-      this.size = entries.limit();
-      this.capacity = entries.limit();
-    }
-
-    try {
-      // Clear VAO to prevent unintended state change.
-      GLES30.glBindVertexArray(0);
-      GLError.maybeThrowGLException("Failed to unbind vertex array", "glBindVertexArray");
-
-      GLES30.glGenBuffers(1, bufferId, 0);
-      GLError.maybeThrowGLException("Failed to generate buffers", "glGenBuffers");
-
-      GLES30.glBindBuffer(target, bufferId[0]);
-      GLError.maybeThrowGLException("Failed to bind buffer object", "glBindBuffer");
-
-      if (entries != null) {
-        entries.rewind();
-        GLES30.glBufferData(
-            target, entries.limit() * numberOfBytesPerEntry, entries, GLES30.GL_DYNAMIC_DRAW);
-      }
-      GLError.maybeThrowGLException("Failed to populate buffer object", "glBufferData");
-    } catch (Throwable t) {
-      free();
-      throw t;
-    }
-  }
-
-  public void set(Buffer entries) {
-    // Some GPU drivers will fail with out of memory errors if glBufferData or glBufferSubData is
-    // called with a size of 0, so avoid this case.
-    if (entries == null || entries.limit() == 0) {
-      size = 0;
-      return;
-    }
-    if (!entries.isDirect()) {
-      throw new IllegalArgumentException("If non-null, entries buffer must be a direct buffer");
-    }
-    GLES30.glBindBuffer(target, bufferId[0]);
-    GLError.maybeThrowGLException("Failed to bind vertex buffer object", "glBindBuffer");
-
-    entries.rewind();
-
-    if (entries.limit() <= capacity) {
-      GLES30.glBufferSubData(target, 0, entries.limit() * numberOfBytesPerEntry, entries);
-      GLError.maybeThrowGLException("Failed to populate vertex buffer object", "glBufferSubData");
-      size = entries.limit();
-    } else {
-      GLES30.glBufferData(
-          target, entries.limit() * numberOfBytesPerEntry, entries, GLES30.GL_DYNAMIC_DRAW);
-      GLError.maybeThrowGLException("Failed to populate vertex buffer object", "glBufferData");
-      size = entries.limit();
-      capacity = entries.limit();
-    }
-  }
-
-  public void free() {
-    if (bufferId[0] != 0) {
-      GLES30.glDeleteBuffers(1, bufferId, 0);
-      GLError.maybeLogGLError(Log.WARN, TAG, "Failed to free buffer object", "glDeleteBuffers");
-      bufferId[0] = 0;
-    }
-  }
-
-  public int getBufferId() {
-    return bufferId[0];
-  }
-
-  public int getSize() {
-    return size;
-  }
-}
Index: app/src/main/java/com/example/memotion/arcamera/model/Place.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/model/Place.java b/app/src/main/java/com/example/memotion/arcamera/model/Place.java
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/example/memotion/arcamera/model/Place.java	
@@ -0,0 +1,54 @@
+package com.example.memotion.arcamera.model;
+
+import com.google.android.gms.maps.model.LatLng;
+import com.google.ar.sceneform.math.Vector3;
+
+public class Place {
+    private String id;
+    private String icon;
+    private String name;
+    private Geometry geometry;
+
+    public Place(String id, String icon, String name, Geometry geometry) {
+        this.id = id;
+        this.icon = icon;
+        this.name = name;
+        this.geometry = geometry;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public Geometry getGeometry() {
+        return geometry;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        Place place = (Place) obj;
+        return id.equals(place.id);
+    }
+
+    @Override
+    public int hashCode() {
+        return id.hashCode();
+    }
+
+    public Vector3 getPositionVector(float azimuth, LatLng latLng) {
+        LatLng placeLatLng = this.geometry.getLocation().getLatLng();
+        // TODO: compute heading
+        double heading = 0.0;
+        float r = -2f;
+        float x = (float) (r * Math.sin(azimuth + heading));
+        float y = 1f;
+        float z = (float) (r * Math.cos(azimuth + heading));
+        return new Vector3(x, y, z);
+    }
+}
Index: app/src/main/java/com/example/memotion/arcamera/api/NearbyPlacesResponse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/api/NearbyPlacesResponse.java b/app/src/main/java/com/example/memotion/arcamera/api/NearbyPlacesResponse.java
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/example/memotion/arcamera/api/NearbyPlacesResponse.java	
@@ -0,0 +1,18 @@
+package com.example.memotion.arcamera.api;
+
+import com.example.memotion.arcamera.model.Place;
+import com.google.gson.annotations.SerializedName;
+import java.util.List;
+
+public class NearbyPlacesResponse {
+    @SerializedName("results")
+    private List<Place> results;
+
+    public NearbyPlacesResponse(List<Place> results) {
+        this.results = results;
+    }
+
+    public List<Place> getResults() {
+        return results;
+    }
+}
\ No newline at end of file
Index: app/src/main/res/layout/activity_ar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.example.memotion.arcamera.ArActivity\">\n\n    <android.opengl.GLSurfaceView\n        android:id=\"@+id/surfaceview\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:layout_gravity=\"top\"/>\n\n</RelativeLayout>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/activity_ar.xml b/app/src/main/res/layout/activity_ar.xml
--- a/app/src/main/res/layout/activity_ar.xml	
+++ b/app/src/main/res/layout/activity_ar.xml	
@@ -1,14 +1,16 @@
 <?xml version="1.0" encoding="utf-8"?>
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    tools:context="com.example.memotion.arcamera.ArActivity">
+    android:orientation="vertical"
+    tools:context=".MainActivity">
 
-    <android.opengl.GLSurfaceView
-        android:id="@+id/surfaceview"
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent"
-        android:layout_gravity="top"/>
+    <fragment android:name="com.example.memotion.arcamera.ar.PlacesArFragment"
+        android:id="@+id/ar_fragment"
+        android:layout_width="match_parent"
+        android:layout_height="0dp"
+        android:layout_weight="7"/>
 
-</RelativeLayout>
+</LinearLayout>
\ No newline at end of file
Index: app/src/main/java/com/example/memotion/arcamera/model/GeometryLocation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/model/GeometryLocation.java b/app/src/main/java/com/example/memotion/arcamera/model/GeometryLocation.java
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/example/memotion/arcamera/model/GeometryLocation.java	
@@ -0,0 +1,17 @@
+package com.example.memotion.arcamera.model;
+
+import com.google.android.gms.maps.model.LatLng;
+
+public class GeometryLocation {
+    private double lat;
+    private double lng;
+
+    public GeometryLocation(double lat, double lng) {
+        this.lat = lat;
+        this.lng = lng;
+    }
+
+    public LatLng getLatLng() {
+        return new LatLng(lat, lng);
+    }
+}
Index: app/src/main/java/com/example/memotion/arcamera/model/Geometry.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/model/Geometry.java b/app/src/main/java/com/example/memotion/arcamera/model/Geometry.java
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/example/memotion/arcamera/model/Geometry.java	
@@ -0,0 +1,13 @@
+package com.example.memotion.arcamera.model;
+
+public class Geometry {
+    private GeometryLocation location;
+
+    public Geometry(GeometryLocation location) {
+        this.location = location;
+    }
+
+    public GeometryLocation getLocation() {
+        return location;
+    }
+}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><project version=\"4\">\n  <component name=\"ExternalStorageConfigurationManager\" enabled=\"true\" />\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_17\" project-jdk-name=\"corretto-17\" project-jdk-type=\"JavaSDK\">\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\n  </component>\n  <component name=\"ProjectType\">\n    <option name=\"id\" value=\"Android\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	
+++ b/.idea/misc.xml	
@@ -1,6 +1,6 @@
 <project version="4">
   <component name="ExternalStorageConfigurationManager" enabled="true" />
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" project-jdk-name="corretto-17" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="jbr-17" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
Index: app/src/main/res/layout/activity_ar_info.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/activity_ar_info.xml b/app/src/main/res/layout/activity_ar_info.xml
new file mode 100644
--- /dev/null	
+++ b/app/src/main/res/layout/activity_ar_info.xml	
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <ImageView
+        android:id="@+id/imageView4"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        app:srcCompat="@drawable/keyword_bg"
+        tools:layout_editor_absoluteX="16dp"
+        tools:layout_editor_absoluteY="16dp" />
+
+    <TextView
+        android:id="@+id/placeKeyword"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="키워드"
+        android:textSize="24sp"
+        app:layout_constraintBottom_toBottomOf="@+id/imageView4"
+        app:layout_constraintEnd_toEndOf="@+id/imageView4"
+        app:layout_constraintStart_toStartOf="@+id/imageView4"
+        app:layout_constraintTop_toTopOf="@+id/imageView4" />
+</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
Index: app/src/main/java/com/example/memotion/arcamera/ar/PlacesArFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/ar/PlacesArFragment.java b/app/src/main/java/com/example/memotion/arcamera/ar/PlacesArFragment.java
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/example/memotion/arcamera/ar/PlacesArFragment.java	
@@ -0,0 +1,13 @@
+package com.example.memotion.arcamera.ar;
+
+import android.Manifest;
+import com.google.ar.sceneform.ux.ArFragment;
+
+public class PlacesArFragment extends ArFragment {
+
+    @Override
+    public String[] getAdditionalPermissions() {
+        // TODO: return location permission
+        return new String[0];
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/example/memotion/arcamera/ar/PlaceNode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/ar/PlaceNode.java b/app/src/main/java/com/example/memotion/arcamera/ar/PlaceNode.java
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/example/memotion/arcamera/ar/PlaceNode.java	
@@ -0,0 +1,71 @@
+package com.example.memotion.arcamera.ar;
+
+import android.content.Context;
+import android.os.Build;
+import android.view.View;
+import android.widget.TextView;
+import com.google.ar.sceneform.Node;
+import com.google.ar.sceneform.rendering.ViewRenderable;
+import com.example.memotion.R;
+import com.example.memotion.arcamera.model.Place;
+
+public class PlaceNode extends Node {
+
+    private Context context;
+    private Place place;
+    private ViewRenderable placeRenderable;
+    private TextView textViewPlace;
+
+    public PlaceNode(Context context, Place place) {
+        this.context = context;
+        this.place = place;
+    }
+
+    @Override
+    public void onActivate() {
+        super.onActivate();
+
+        if (getScene() == null) {
+            return;
+        }
+
+        if (placeRenderable != null) {
+            return;
+        }
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            ViewRenderable.builder()
+                    .setView(context, R.layout.activity_ar_info)
+                    .build()
+                    .thenAccept(renderable -> {
+                        setRenderable(renderable);
+                        placeRenderable = renderable;
+
+                        if (place != null) {
+//                            textViewPlace = renderable.getView().findViewById(R.id.placeName);
+                            textViewPlace.setText(place.getName());
+                        }
+                    });
+        }
+    }
+
+    public void showInfoWindow() {
+        // Show text
+        if (textViewPlace != null) {
+            textViewPlace.setVisibility(textViewPlace.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);
+        }
+
+        // Hide text for other nodes
+        Node parent = getParent();
+        if (parent != null) {
+            for (Node child : parent.getChildren()) {
+                if (child instanceof PlaceNode && child != this) {
+                    ((PlaceNode) child).textViewPlace.setVisibility(View.GONE);
+                }
+            }
+        }
+    }
+    public Place getPlace() {
+        return place;
+    }
+}
Index: app/src/main/java/com/example/memotion/arcamera/api/PlacesService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/memotion/arcamera/api/PlacesService.java b/app/src/main/java/com/example/memotion/arcamera/api/PlacesService.java
new file mode 100644
--- /dev/null	
+++ b/app/src/main/java/com/example/memotion/arcamera/api/PlacesService.java	
@@ -0,0 +1,40 @@
+package com.example.memotion.arcamera.api;
+
+import okhttp3.OkHttpClient;
+import okhttp3.logging.HttpLoggingInterceptor;
+import retrofit2.Call;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.http.GET;
+import retrofit2.http.Query;
+
+
+public interface PlacesService {
+
+    @GET("nearbysearch/json")
+    Call<NearbyPlacesResponse> nearbyPlaces(
+            @Query("key") String apiKey,
+            @Query("location") String location,
+            @Query("radius") int radiusInMeters,
+            @Query("type") String placeType
+    );
+
+    class Factory {
+        private static final String ROOT_URL = "https://maps.googleapis.com/maps/api/place/";
+
+        public static PlacesService create() {
+            HttpLoggingInterceptor logger = new HttpLoggingInterceptor();
+            logger.level(HttpLoggingInterceptor.Level.BODY);
+            OkHttpClient okHttpClient = new OkHttpClient.Builder()
+                    .addInterceptor(logger)
+                    .build();
+            GsonConverterFactory converterFactory = GsonConverterFactory.create();
+            Retrofit retrofit = new Retrofit.Builder()
+                    .baseUrl(ROOT_URL)
+                    .client(okHttpClient)
+                    .addConverterFactory(converterFactory)
+                    .build();
+            return retrofit.create(PlacesService.class);
+        }
+    }
+}
